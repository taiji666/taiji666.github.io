import{_ as s,c as i,G as a,b as n}from"./chunks/framework.D5KJDRhN.js";const e=JSON.parse('{"title":"26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇","description":"","frontmatter":{"title":"26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇.md","lastUpdated":1739887664000}');const p=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇.md"},[["render",function(s,e,p,l,t,h){return n(),i("div",null,e[0]||(e[0]=[a('<h3 id="rxjs-核心思想-响应式编程" tabindex="-1">RxJS 核心思想：响应式编程 <a class="header-anchor" href="#rxjs-核心思想-响应式编程" aria-label="Permalink to &quot;RxJS 核心思想：响应式编程&quot;">​</a></h3><h4 id="rxjs-是个啥" tabindex="-1">RxJS 是个啥 <a class="header-anchor" href="#rxjs-是个啥" aria-label="Permalink to &quot;RxJS 是个啥&quot;">​</a></h4><p>RxJS 是一个在 JavaScript 中实现响应式编程的库，它利用可观察序列（<strong>Observable</strong>）来表达异步数据流，并通过一系列的操作符（<strong>Operators</strong>）来对这些数据流进行转换、筛选和组合，最终实现业务逻辑。</p><blockquote><p>注：可观察序列（Observable）这个东西我们下文还会展开讲解，这里大家先记住这个名字就可以了。</p></blockquote><p>下面是一个简单的 RxJS 示例代码（基于 RxJS6 编写），展示如何基于可观察序列来实现状态管理：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fromEvent } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;rxjs&#39;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { map, filter, debounceTime } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;rxjs/operators&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取输入框 DOM </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> searchInput</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;search-input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fromEvent可以将一个 DOM 转换为一个可观察的对象（Observable）</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> input$</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fromEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(searchInput, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.target.value),</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    debounceTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">input$.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Performing search with query &quot;${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;...`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 发起异步请求，并更新页面</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>注：在示例中，变量名以 $ 开头是为了表明这是一个流对象。这是 RxJS 的一种（可选的）命名约定，目的是为了帮开发者在代码中快速识别出这是一个流对象，而不是普通的变量或函数。</p></blockquote><p>上面的代码使用 RxJS 监听了一个输入框的值变化，当输入框的值变化后，我们借助 <code>map</code> 操作符将事件对象转换为输入框的值，然后通过 <code>filter</code> 操作符过滤掉长度小于等于 2 的输入，最后通过 <code>debounceTime</code> 操作符确保用户停止输入一段时间后才会发出值。这样就可以避免在用户快速输入时频繁地执行搜索操作。</p><p>通过这个示例，我们可以看到 RxJS 中提供了强大的<strong>操作符</strong>和<strong>工具函数</strong>，使得我们能够非常方便地对数据流进行处理和转换，从而实现响应式的状态管理。</p><blockquote><p>注：在 RxJS 中，操作符（<strong>operators</strong>）是用来组合 Observable 的纯函数，用于对 Observable 进行各种转换、过滤、合并等操作。RxJS 中提供了大量的操作符，例如 map、filter、mergeMap、switchMap 等等，楼上我们用到的操作符有 <code>map</code>和<code>filter</code>。<br> 而工具函数（<strong>utility functions</strong>）则是一些不依赖于 Observable 的纯函数，用于处理 Observable 发射出来的值。RxJS 中提供了大量的工具函数，例如 tap、delay、timeout 等等。在楼上的示例中，我们用到的工具函数是 <code>fromEvent</code>。</p></blockquote><h4 id="从函数式编程到响应式编程" tabindex="-1">从函数式编程到响应式编程 <a class="header-anchor" href="#从函数式编程到响应式编程" aria-label="Permalink to &quot;从函数式编程到响应式编程&quot;">​</a></h4><p>接下来我会试着讨论函数式编程和响应式编程的差异，然后你就会发现，它们<s>真的没有什么特别的差异（笑死）</s> 真的是非常相似的两个范式。</p><p>尽管两者的共性非常之多（都属于<strong>声明式编程</strong>，都<strong>遵循函数式编程的基本原则</strong>），但差异还是有的，那就是关注点的不同：</p><p>函数式编程强调的是<strong>函数的组合和变换</strong>，通过将复杂的问题分解成小的函数，再将这些函数组合起来，达到解决问题的目的。函数式编程中，函数是“一等公民”。</p><p>响应式编程强调的是<strong>数据流的变化和响应</strong>，它将复杂的问题抽象成一个数据流，通过对数据流进行变换和响应，达到解决问题的目的。响应式编程中，函数仍然是“一等公民”，但它更强调对“数据流”的关注。</p><p>总之一句话：<strong>函数式编程关注函数，响应式编程关注数据流</strong>。</p><p>话是这么说没错，但是在我看来，个人实在是不习惯去做响应式编程和函数式编程的辨析——目前业内比较广为接受的一种观点是“<strong>响应式编程是函数式编程的一种扩展和补充</strong>”，这和我个人的观点也是一致的。因此，我们可以把响应式编程视作函数式编程的一个分支流派，<strong>这个流派在函数式思想的基础上，更加强调对数据流的关注</strong>。</p><h3 id="rxjs-对-盒子模式-的运用" tabindex="-1">RxJS 对“盒子模式”的运用 <a class="header-anchor" href="#rxjs-对-盒子模式-的运用" aria-label="Permalink to &quot;RxJS 对“盒子模式”的运用&quot;">​</a></h3><p>作为一本函数式编程小册，这里我给大家介绍 RxJS，当然不全是为了做楼上这种老八股式的概念辨析题。我真正的目的，是为了给大家点出两件非常重要的事情：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1.  **“盒子模式”** 不是花拳绣腿，它真的**是可以用来写生产级别的代码的**</span></span>\n<span class="line"><span>1.  **Monad** 除了可以实现数据转换、可以解决“嵌套盒子”问题，它还可以帮我们【**把副作用放进盒子**】</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="盒子模式-生产实践-rxjs-中的-monad-与-functor" tabindex="-1">“盒子模式”生产实践：RxJS 中的 Monad 与 Functor <a class="header-anchor" href="#盒子模式-生产实践-rxjs-中的-monad-与-functor" aria-label="Permalink to &quot;“盒子模式”生产实践：RxJS 中的 Monad 与 Functor&quot;">​</a></h3><p>通过<a href="https://juejin.cn/book/7173591403639865377/section/7175422979646423098" target="_blank" rel="noreferrer">第 17 节</a>-<a href="https://juejin.cn/book/7173591403639865377/section/7175422691443212348" target="_blank" rel="noreferrer">第 19 节</a>的学习，我们已经知道，Functor 是指实现了<code>map</code>函数的盒子，而 Monad 则是指实现了<code>map</code>和<code>flatMap</code>函数的盒子。</p><p><strong>在 RxJS 中，</strong> <code>Observable</code> <strong>既是一个 Functor，也是一个 Monad。</strong></p><p>请看下面这段代码（注意，下面代码基于 <strong>RxJS5</strong> 编写，在 RxJS6 中，<code>flatMap</code>和<code>map</code>仍然存在，但是写法没有 RxJS5 这么直观。为了降低大家的理解成本，这里我选择了使用 RxJS5 来写盒子模式的示例） ：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Rx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;rxjs&quot;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Observable } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;rxjs/Observable&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// observable 是一个 Observable 类型的盒子，它既是 Functor 也是 Monad</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> observable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// observable 是一个 Functor，可以调用 Functor 的 map 方法</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mappedBox</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// observable 是一个 Monad，可以调用 Monad 的 flatMap 方法，把嵌套的 Functor 拍平</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> flattenObservable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([x, x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以通过订阅打印出盒子的内容</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：1, 2, 3</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val))</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：2, 4, 6</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mappedBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val))</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：1, 2, 2, 4, 3, 6</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flattenObservable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在这个例子中，我们使用 RxJS 的<code>from</code>操作符将一个数组转换成了一个<code>Observable</code>类型的盒子：<code>observable</code>。由于<code>Observable</code>盒子实现了<code>map</code>函数，我们可以像使用数组的<code>map</code>函数一样，对<code>observable</code>进行变换得到一个新的<code>Observable</code>盒子。这个过程中，<code>Observable</code>充当了 <strong>Functor</strong> 的角色。</p><p><code>flatMap</code><strong>函数则不同于</strong><code>map</code><strong>函数，它不仅可以进行变换，还可以将嵌套的</strong><code>Observable</code><strong>结构展平。</strong></p><blockquote><p>还记得我们<a href="https://juejin.cn/book/7173591403639865377/section/7175422691443212348" target="_blank" rel="noreferrer">第 19 节</a>的标题中“嵌套盒子解决方案”这个描述吗？这里就用上啦！</p></blockquote><p>我们通过在 <code>flatMap</code>的回调函数中调用 <code>from</code>方法，将<code>observable</code>中的每个元素从数字转换为了<code>Observable</code>盒子（对应示例中的第 11 行代码，如下）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// observable 是一个 Monad，可以调用 Monad 的 flatMap 方法，把嵌套的 Functor 拍平</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> flattenObservable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([x, x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于<code>observable</code>本身是一个 <code>Observable</code>盒子，这波转换相当于是在盒子里面套了新的盒子。如果我们调用的是<code>map</code>而不是<code>flatMap</code>，那么映射出来的结果就会是一个嵌套的盒子。像这样：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nestedObservable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([x, x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;nestedObservable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nestedObservable)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nestedObservable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;val is:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, val))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>nestedObservable</code> 本身是一个盒子，如下图：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3a88e2584e4cd4a402d55d10ba1e3b~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3a88e2584e4cd4a402d55d10ba1e3b~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p><code>nestedObservable</code> 内部存储的 <code>val</code> 也是一系列的盒子，如下图：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e962408ffd49d487bd4f52590d236c~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e962408ffd49d487bd4f52590d236c~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>但我们知道，<code>flatMap</code>是可以处理嵌套盒子的场景的。这里使用<code>flatMap</code>，就可以将嵌套的双层 <code>Observable</code>盒子展开为一个单层的<code>Observable</code>对象：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// observable 是一个 Monad，可以调用 Monad 的 flatMap 方法，把嵌套的 Functor 拍平</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> flattenObservable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([x, x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出一个 Observable 盒子</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;flattenObservable&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, flattenObservable)    </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出具体的 val 值：1、2、2、4、3、6</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flattenObservable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;val is:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, val))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74fb4d98fec74a9393de155853af1fe2~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74fb4d98fec74a9393de155853af1fe2~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>如大家所见，由于同时具备 <code>map</code>能力和<code>flatMap</code>能力，所以 <strong>Observable 盒子既是一个 Functor，也是一个 Monad</strong>。</p><h3 id="monad-的另一面-把-副作用-放进盒子。" tabindex="-1">Monad 的另一面：把“副作用”放进盒子。 <a class="header-anchor" href="#monad-的另一面-把-副作用-放进盒子。" aria-label="Permalink to &quot;Monad 的另一面：把“副作用”放进盒子。&quot;">​</a></h3><p>当使用 RxJS 时，我们经常会遇到需要在异步数据流中执行副作用的情况，这时 RxJS 就会使用 Monad 来处理这些副作用。这里也就引出了 Monad 的“另一面”：<strong>把“副作用”放进盒子——我们可以将具有副作用的操作封装在 Monad 中，以便于隔离其它函数对副作用的关注。</strong></p><p>请大家看这样一个例子（仍然是基于 RxJS5 的）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Rx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;rxjs&quot;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Observable } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;rxjs/Observable&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里我用 setTimeout 模拟一个网络请求</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">complete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 处理数据的纯函数</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用副作用放进盒子的方式处理网络请求</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boxedData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Observable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flatMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 订阅处理结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boxedData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(processData).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &quot;DATA&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>在上面的例子中，我们将网络请求这个副作用包裹在一个 <code>Observable</code> 盒子中（上面已经分析过，<code>Observable</code> 盒子是一个 Monad），并将盒子的执行结果作为一个值“发射”出去，这个值可以被后续的<code>map()</code>操作消费和处理。<strong>这个过程中，</strong> <code>Observable</code> <strong>就是一个专门用来消化副作用的盒子——它将异步操作封装在内部，防止了副作用的外泄。</strong></p><p>这样做有什么好处呢？我们可以注意到，<code>processData()</code> 是一个<strong>纯函数</strong>，它负责将传入的数据转换成大写字母，没有任何副作用。我们将 <code>processData()</code> 函数传递给 <code>map()</code> 方法，<code>map()</code>方法就会在原有的 Observable 盒子的每个值上调用这个纯函数，并将处理结果放到新的 Observable 盒子中——<strong>这整个过程都是纯的</strong>。</p><p>大家细品一下这个过程：在整个 <code>boxData</code>盒子的调用链中，<code>boxData</code>本身作为一个 Monad 盒子，它是不纯的；末尾的 <code>subscribe()</code>函数涉及到了在控制台输出数据，它也是不纯的。但<strong>夹在这两者中间的所有</strong> <code> map()</code><strong>调用都是纯的</strong>。</p><p>也就是说，这种模式能够帮助我们<strong>把纯函数和副作用分离开来，保证盒子和</strong> <code> subscribe()</code><strong>回调之间的所有逻辑的纯度</strong>。此外，使用 Monad 封装副作用，也可以使代码更加模块化，可维护性更高。</p><h3 id="更进一步-【函数管道】将生产端-消费端分离" tabindex="-1">更进一步：【函数管道】将生产端-消费端分离 <a class="header-anchor" href="#更进一步-【函数管道】将生产端-消费端分离" aria-label="Permalink to &quot;更进一步：【函数管道】将生产端-消费端分离&quot;">​</a></h3><p>在 RxJS 中，<code>Observable</code> 负责生产数据，而 <code>Observer</code> 负责消费数据。</p><p>在楼上的例子中，<code>boxedData</code> 是一个生产数据的 <code>Observable</code>，而 <code>subscribe</code> 方法所传入的回调函数则是消费数据的 <code>Observer</code>。</p><p><code>Observable</code>（生产端）和 <code>Observer</code>（消费端）都可能涉及副作用，例如异步请求、打印日志等等。因此它们都是<strong>不纯</strong>的。</p><p>但是，<strong>那些夹在</strong> <code>Observable</code> <strong>和</strong> <code>Observer</code> <strong>之间的操作，例如</strong> <code>map</code> <strong>、</strong> <code>filter</code> <strong>、</strong> <code>merge</code> <strong>等等，这些操作专注于数据的计算，并不关心数据的来源和去处、不涉及外部环境</strong>，因此它们总是纯的。</p><p>这也就是说，<strong>RxJS 背靠函数式编程的思想，在</strong> <code>Observable</code> <strong>和</strong> <code>Observer</code> <strong>之间架起了一条“函数管道”</strong> 。生产端 <code>Observable</code> 将数据“发射”出去后，数据首先会经过这条“<strong>管道</strong>”，在“<strong>管道</strong>”中完成所有的计算工作后，才会抵达消费端 <code>Observer</code>。</p><p>对于 RxJS 来说，想和外界发生交互，只能通过管道的首尾两端（也即生产端、消费端）。管道内部是由纯函数组成的，这就保证了整个计算过程的可靠性和可预测性。同时，通过这条“管道”，<strong>生产端</strong> <code>Observable</code> <strong>和消费端</strong> <code>Observer</code> <strong>被有效地分离，实现了高度的解耦</strong>。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>通过这两节的学习，相信大家不仅能够切身感受到 FP 思想对于前端状态管理这个细分领域的影响之深，也会对 FP 三大特征中“<strong>拥抱纯函数，隔离副作用</strong>”这一点有更深的感悟。</p><p>我们在小册<a href="https://juejin.cn/book/7173591403639865377/section/7175420951075504188" target="_blank" rel="noreferrer">第 4 节</a>曾经强调过，“<strong>副作用不是毒药</strong>”：</p><blockquote><p>对于我们程序员来说，实践纯函数的目的并不是消灭副作用，而是将计算逻辑与副作用做合理的分层解耦，从而提升我们的编码质量和执行效率。 ——本册第 4 节</p></blockquote><p>Monad 将副作用放进盒子这个模式，正是基于这一思想衍生出来的。RxJS 借助 Monad 将副作用放进 Observable 盒子中、将计算逻辑和副作用进行了分层，更是为我们做了一个绝佳的示范。</p><p>但这一模式并不是 RxJS 的专利——作为一个成熟的函数式模式，它在程序世界的应用是非常广泛的：比如 Haskell 中的 IO Monad、Scala 中的 Future Monad、Clojure 中的 Monadic I/O library 以及 Rust 中的 futures-rs 库等等......以这些语言和库为代表的生产级的 Monad 实现，也都会践行用 Monad 来隔离副作用的模式。</p>',61)]))}]]);export{e as __pageData,p as default};
