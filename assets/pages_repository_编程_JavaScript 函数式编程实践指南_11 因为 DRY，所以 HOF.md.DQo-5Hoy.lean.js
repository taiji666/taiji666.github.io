import{_ as s,c as i,G as a,b as n}from"./chunks/framework.D5KJDRhN.js";const p=JSON.parse('{"title":"11 因为 DRY，所以 HOF","description":"","frontmatter":{"title":"11 因为 DRY，所以 HOF","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/11 因为 DRY，所以 HOF"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/11 因为 DRY，所以 HOF.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/11 因为 DRY，所以 HOF.md","lastUpdated":1739887664000}');const l=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/11 因为 DRY，所以 HOF.md"},[["render",function(s,p,l,h,k,e){return n(),i("div",null,p[0]||(p[0]=[a('<blockquote><p>标题注解：DRY(Don&#39;t Repeat Yourself) 是一种软件设计原则，HOF(High Order Function)指高阶函数。</p></blockquote><h2 id="李雷的前端生涯第一课" tabindex="-1">李雷的前端生涯第一课 <a class="header-anchor" href="#李雷的前端生涯第一课" aria-label="Permalink to &quot;李雷的前端生涯第一课&quot;">​</a></h2><p>在展开 DRY 和 HOF 这两个话题之前，我们不妨先来看一个发生在实际研发过程中的案例。</p><p>（以下案例基于作者在现实生活中的工作经历，如有雷同，纯属缘分~）</p><h3 id="李雷很累-我很困惑" tabindex="-1">李雷很累，我很困惑 <a class="header-anchor" href="#李雷很累-我很困惑" aria-label="Permalink to &quot;李雷很累，我很困惑&quot;">​</a></h3><p>两年前，我所在的团队启动了一个性能监控的技术专项。</p><p>其中涉及到一个和函数计算相关的监控指标，期望可以拿到业务中每个函数的执行时间，以此来估算整体的前端计算效率。</p><p>我把这个活交给了团队刚来的实习生小伙子李雷。</p><p>我说：小兄弟，这个不着急，接下来一周可以慢慢做，慢工才能出细活嘛。</p><p>李雷：没问题，请好吧您。</p><p>就这样，一周过去了。</p><p>这天我写完周报，转悠到李雷的工位，想看看功能实现得咋样了。</p><p>我问李雷：这周感觉怎么样？你这边没有啥业务需求，应该挺轻松的吧？</p><p>李雷：轻松个锤子，我快累死了！怪不得外面都说你们团队卷，这么繁重的工作只给我一周，我都想离职了！</p><p>这，一周写一个函数，繁。重。。。？</p><p>我大受震撼。</p><p>说话间，我立刻拉取了李雷的 remote dev 分支，开始帮他做 code review。</p><h3 id="李雷的代码-我很头大" tabindex="-1">李雷的代码，我很头大 <a class="header-anchor" href="#李雷的代码-我很头大" aria-label="Permalink to &quot;李雷的代码，我很头大&quot;">​</a></h3><p>我随手点开了一个已经被李雷改造过的业务函数，它差不多长这样（解析在注释里）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// monitor 指代我们团队自研的性能上报sdk（虽然它实际不叫这个名字），大家意会一下即可</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> monitor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;monitor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computeOrderAmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 开始时间打点</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> startTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 中间是一段超级长的业务逻辑，此处以...省略</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 结束时间打点</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> endTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 调用 monitor，第一个入参标识上报类型，第二个入参是需要上报的时间信息</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  monitor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">report</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;function-compute-time&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 结束时间 - 开始时间，就得到了函数执行需要的时间</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    endTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startTime  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>上面是一个脱敏了 N 次之后的极简版本，在实际上报过程中，我们不仅会收集函数的执行时间，还会上报函数的业务归属、函数的执行上下文、以及一些更加细致琐碎的信息。</p><p>也就是说，虽然这里大家只看到了 3 行有意义的上报代码，但实际情况下，每个函数里和监控上报有关的代码增量估计在 10-20 行之间。</p><p>李雷是怎么做的呢？</p><p>他给业务里的每一个函数，都增加了 10-20 的监控代码。</p><p>那么我们的业务里一共有多少个函数呢？</p><p>保守估计，应该有 1000+。</p><p>我问李雷：你是打算用一周的时间徒手写两万行代码吗？</p><p>李雷义愤填膺：啊？那不然嘞？</p><p>我叹了一口气：朋友，你听说过安利DRY吗？</p><p>李雷一脸错愕：啥？搁这儿背单词了？ Dry 我知道，形容词，adj，干燥的！</p><p><s>我直接好家伙</s>我直接放弃挣扎， 打开 VSCode 给他出了一道题。</p><h3 id="小试牛刀-对一个数组进行自定义迭代计算" tabindex="-1">小试牛刀：对一个数组进行自定义迭代计算 <a class="header-anchor" href="#小试牛刀-对一个数组进行自定义迭代计算" aria-label="Permalink to &quot;小试牛刀：对一个数组进行自定义迭代计算&quot;">​</a></h3><p>题目——使用原生 JS，实现如下三个函数：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  迭代做加法：函数入参为一个数字数组，对数组中每个元素做 +1 操作，并把计算结果输出到一个新数组 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`newArr`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fe：输入</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`  [1,2,3] `</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，输出</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`  [2,3,4] `</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  迭代做乘法：函数入参为一个数字数组，对数组中每个元素做 *3 操作，并把计算结果输出到一个新数组 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`newArr`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fe：输入</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`  [1,2,3] `</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，输出 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[3,6,9]`</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  迭代做除法：函数入参为一个数字数组，对数组中每个元素做 /2 操作，并把计算结果输出到一个新数组 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`newArr`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fe：输入 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[2,4,6]`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，输出 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[1,2,3]`</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这题不难，李雷刷刷两下就做完了，他交出的代码如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 迭代做加法</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrAdd1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []  </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 迭代做乘法 </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrMult3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []  </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 迭代做除法</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrDivide2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []  </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 [2, 3, 4]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrAdd1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))   </span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 [3, 6, 9]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrMult3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])) </span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 [1, 2, 3]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrDivide2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>我们可以看到，这三个函数的输出都是符合预期的，代码逻辑也没有毛病。</p><p>问题出在代码的设计上，李雷忘记了 DRY 原则。</p><h2 id="什么是-dry-原则" tabindex="-1">什么是 DRY 原则？ <a class="header-anchor" href="#什么是-dry-原则" aria-label="Permalink to &quot;什么是 DRY 原则？&quot;">​</a></h2><p>DRY 是一个缩写，全拼是 Don&#39;t Repeat Yourself。</p><p>直译过来，就是“不要重复你自己”</p><p>这是一个重要的设计原则，也是程序员的基本行事准则。</p><p>具体到编码上来，就是提醒我们，不要做重复的工作，不要把同一段代码写N次。</p><p>当我们多次遇到同一个问题，多次用到重复的解法时，我们就应该把重复的这部分提取出来，而不是 ctrl-c + ctrl-v 四处复制粘贴。</p><h2 id="dry-原则的-js-实践-hof-高阶函数" tabindex="-1">DRY 原则的 JS 实践：HOF(高阶函数） <a class="header-anchor" href="#dry-原则的-js-实践-hof-高阶函数" aria-label="Permalink to &quot;DRY 原则的 JS 实践：HOF(高阶函数）&quot;">​</a></h2><p>现在我们本着 DRY 的原则，对李雷的答案做一波改造。</p><p>实践 DRY 原则最重要的一点，就是将“变与不变”分离。这也是我在设计模式小册中反复跟大家强调的一个核心的设计原则。</p><p>就李雷的代码来说，“变与不变”分别对应哪些逻辑？</p><p>很明显，对于这三个函数来说，迭代loop、数组push动作都是一毛一样的，变化的仅仅是循环体里的数学算式而已。</p><p>数学算式是“变”，其余逻辑是“不变”。</p><p>我们把不变的逻辑提取出来，代码如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrCompute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []  </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // xxx 指的是变化的算式</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xxx)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>不变的代码，我们应该把它提取为一个通用的函数。</p><p>变化的部分怎么处理呢？</p><p>大家可以思考一下，对于一个函数来说，它的三个要素（入参、函数体、出参）里，哪些要素是动态的？</p><p>这时不妨回顾一下，什么是函数？函数就是下面这个东西：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>y = f(x)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>出参 <code>y</code> 是因变量，函数体 <code>f</code> 是计算逻辑，函数入参 <code>x</code> 就是自变量。</p><p>函数体一旦被定义了就无法再修改，所以，我们使用函数体来承接“不变”。</p><p>因变量和自变量都是动态可变的，但因变量变化的前提是自变量的变化。</p><p>自变量确定的情况下，因变量也是不变的。</p><p>因此，唯一可以用来承接“变”的要素，只有自变量。也就是函数的入参。</p><p>我们要想办法把变化的算式，作为一个入参传递给 <code>arrCompute()</code>。</p><p>在一些语言中，你或许可以直接把一坨计算逻辑作为入参传递给函数。但在 JS 的世界里，这是行不通的，要想把逻辑作为入参传递，我们必须把它包装成函数。</p><p>于是，本着“不变”构造成通用函数体，“变”包装成函数作为入参传递的原则，我们可以把李雷的代码改写成下面这样：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// +1 函数 </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// *3函数</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mult3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// /2函数</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> divide2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrCompute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []  </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 变化的算式以函数的形式传入</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newArr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr[i]))</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 [2, 3, 4]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrCompute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], add1))</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 [3, 6, 9]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrCompute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], mult3)) </span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 [1, 2, 3]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arrCompute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], divide2))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>这样一来，我们就用一种更简洁、更优美的姿势，实现了同样的功能。</p><p>其中的 <code>arrCompute()</code> 函数，就是一个高阶函数。</p><p><strong>高阶函数，指的就是接收函数作为入参，或者将函数作为出参返回的函数。</strong></p><h2 id="why-hof——高阶函数改造前后对比" tabindex="-1">WHY HOF——高阶函数改造前后对比 <a class="header-anchor" href="#why-hof——高阶函数改造前后对比" aria-label="Permalink to &quot;WHY HOF——高阶函数改造前后对比&quot;">​</a></h2><p>既然实现的都是同样的功能，为什么我们程序员一定要 DRY、为什么用高阶函数来做就比复制粘贴梭哈更好呢？</p><p>我们从几个不同的角度来聊聊这个话题。</p><h3 id="更简洁的代码-方便读写" tabindex="-1">更简洁的代码，方便读写 <a class="header-anchor" href="#更简洁的代码-方便读写" aria-label="Permalink to &quot;更简洁的代码，方便读写&quot;">​</a></h3><p>别的不说，咱就直接先看楼上的这个例子。</p><p>对比数组计算这几个函数，改造后的代码，给人最直接的感受，就是比改造前的代码要简洁许多。</p><p>这个 case 里我们提取的公共逻辑不算很复杂，实际上越复杂的公共逻辑，提取前后的代码行数对比越明显。</p><p>通过抽取重复的逻辑到高阶函数里，我们可以减少大量复制粘贴带来的冗余代码。</p><p>更少的代码，意味着更小的编码负担，更好的可读性。</p><h4 id="更小的编码负担" tabindex="-1">更小的编码负担 <a class="header-anchor" href="#更小的编码负担" aria-label="Permalink to &quot;更小的编码负担&quot;">​</a></h4><p>对于李雷的性能上报任务来说，1000个函数，每个函数里人肉增加 20-30 行重复代码，也要写上几万行。</p><p>若能提取一个高阶函数出来，那么他最多只需要给 1000 多个函数逐个包装一层高阶函数的调用。</p><p>几万行 vs 1000多行，四舍五入等于不用写代码（狂笑）。</p><h4 id="更好的可读性" tabindex="-1">更好的可读性 <a class="header-anchor" href="#更好的可读性" aria-label="Permalink to &quot;更好的可读性&quot;">​</a></h4><p>这里我并不是说只有高阶函数能够改善代码的可读性，而是说你提取任意逻辑到一个函数里、然后给它起一个恰当的名字，都能够改善代码的可读性。</p><p>仍然是性能上报这个 case，如果我们不提取代码到高阶函数里，那么同事读到李雷改造过的业务代码，他的反应估计是这样的：</p><p>这里看上去好像被新来的那个小伙子改过了，我来看看具体改了啥。额，1-10行，好像是打了一些时间戳、记录了一些业务上下文；额，倒数后 20 行，好像是在调用性能 sdk，上报一些参数......喔，这原来是在做性能上报啊！</p><p>同事不得不逐行阅读李雷写的每一行代码，才能够推测出他的意图，<strong>因为这段逻辑没有一个名字</strong>。</p><p>而定义函数的过程，恰恰就是给一段逻辑起名字的过程啊，家人们！</p><p>我给这段性能上报的逻辑起名叫 performanceReport，然后在任何一个业务函数调用时，都用 performanceReport 这样包裹它一下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">performanceReport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(anyFunction)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样一来，是不是地球人都能一眼看出来，我这里要做性能上报了？</p><p>这，就是可读性。</p><h3 id="代码可复用-利人利己" tabindex="-1">代码可复用，利人利己 <a class="header-anchor" href="#代码可复用-利人利己" aria-label="Permalink to &quot;代码可复用，利人利己&quot;">​</a></h3><p>用高阶函数，最直接的目的就是为了能够复用代码，减少重复，避免复制粘贴。</p><p>对于李雷来说， 他自己写的代码，自己自然是熟悉的，复制粘贴顶多算是一个体力活。</p><p>但如果明天韩梅梅想写一个类似的功能，她就不得不自己重新实现一遍李雷写过的逻辑。</p><p>对于性能上报这个场景来说，这是我分配给李雷的一个技术专项，如何完成上报、如何调用app底层的性能sdk，按道理其它同事不需要去关注这其中的实现细节。</p><p>但由于李雷没有去做逻辑的提取，导致韩梅梅不得不深入到李雷改造的每一个函数中，去看实现的细节，然后再把这些实现的细节搬运到自己的函数里。</p><p>实践 DRY 原则，不仅仅是为了方便自己的工作，也是为了提升整个团队的研发效率。</p><h3 id="清晰的逻辑边界-更少的测试工作" tabindex="-1">清晰的逻辑边界，更少的测试工作 <a class="header-anchor" href="#清晰的逻辑边界-更少的测试工作" aria-label="Permalink to &quot;清晰的逻辑边界，更少的测试工作&quot;">​</a></h3><p>咱们说了，对于李雷来说， 他自己写的代码，自己自然是熟悉的，复制粘贴顶多算是一个体力活。</p><p>但，谁能保证复制粘贴的过程，不会出错呢？</p><p>有没有可能，李雷在某个业务函数 A 里多贴了一行，在另一个业务函数 B 里少贴了一行，甚至在业务函数 C 里不小心把性能上报代码揉进业务代码里去了，干扰了业务层面的输出。</p><p>这些都是很有可能的，因为李雷是人，人远没有计算机可靠。</p><p>因为不可靠的人类无法保证每一个函数的质量，测试就不得不对 1000 多个函数做全面的回归。</p><p>但实际上，业务函数本身是不变的，我们的本意仅仅是在原有的基础上做一个性能上报的增量而已。</p><p>也就是说，讲道理，如果我们研发能够提前把变与不变通过函数的形式划分清楚，那么测试根本不需要做那么多重复的工作，他只需要对增量部分的函数（也就是高阶函数 performanceReport）做测试就可以了。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本节，我们从一个实习生小兄弟的乌龙事件讲起，从解法、原则、动机等几个方面，全面认识了高阶函数这个东西。</p><p>事实上，高阶函数带来的利好，并不完全是高阶函数所特有的。</p><p>确切来说，这些利好是 DRY 原则带来的，是将“变与不变”明确分离的思维习惯带来的。</p><p>无论是设计模式，还是函数式编程，我总在反复强调“变与不变分离”这回事。在我看来，这一点，可以说是“如何写出好代码”这个问题的终极要义。</p><p>在接下来的几个小节中，我们还会接触到更多的函数式编程之“术”。彼时，相信大家会对这一点有更深刻的感悟。</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',114)]))}]]);export{p as __pageData,l as default};
