import{_ as s,c as a,G as i,b as n}from"./chunks/framework.D5KJDRhN.js";const e=JSON.parse('{"title":"6 不可变数据：函数纯度的“安全帽”","description":"","frontmatter":{"title":"6 不可变数据：函数纯度的“安全帽”","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/6 不可变数据：函数纯度的“安全帽”"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/6 不可变数据：函数纯度的“安全帽”.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/6 不可变数据：函数纯度的“安全帽”.md","lastUpdated":1739887664000}');const p=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/6 不可变数据：函数纯度的“安全帽”.md"},[["render",function(s,e,p,l,t,h){return n(),a("div",null,e[0]||(e[0]=[i('<h2 id="js-世界的-不可变数据" tabindex="-1">JS 世界的“不可变数据” <a class="header-anchor" href="#js-世界的-不可变数据" aria-label="Permalink to &quot;JS 世界的“不可变数据”&quot;">​</a></h2><h3 id="值类型与引用类型" tabindex="-1">值类型与引用类型 <a class="header-anchor" href="#值类型与引用类型" aria-label="Permalink to &quot;值类型与引用类型&quot;">​</a></h3><p>“不可变”是对数据特征的描述，既然说到数据，咱们不妨再回头看一下 JS 世界里的 7 个数据类型：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   String</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Number</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Boolean</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   null</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   undefined</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Symbol</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Object</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>作者注：7种数据类型出自 《JavaScript 高级程序设计》第4版 ，截止小册发行日，ES 标准还新增了一个新的数据类型 BigInt，不过这个不影响我们后续的讨论</p></blockquote><p>JS中的数据类型，整体上来说只有两类：值类型（也称基本类型/原始值）和引用类型（也称复杂类型/引用值）。</p><p>其中值类型包括：String、Number、Boolean、null、undefined、Symbol。这类型的数据最明显的特征是<strong>大小固定、体积轻量、相对简单。</strong></p><p>而排除掉值类型，剩下的 Object 类型就是<strong>引用类型（复杂类型）</strong> 。这类数据相对<strong>复杂、占用空间较大、且大小不定。</strong></p><p>保存值类型的变量是按值访问的， 保存引用类型的变量是按引用访问的。这两类数据之间最大的区别，在于<strong>变量保存了数据之后，我们还能对这个数据做什么</strong>。</p><h3 id="不可变的值-可变的引用内容" tabindex="-1">不可变的值，可变的引用内容 <a class="header-anchor" href="#不可变的值-可变的引用内容" aria-label="Permalink to &quot;不可变的值，可变的引用内容&quot;">​</a></h3><p><strong>值类型的数据无法被修改</strong>，当我们修改值类型变量的时候，本质上会创建一个新的值。</p><p>我们一起来看看下面这个例子：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这段代码对应的控制台执行结果如下图所示：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2d0d2955944223a93f7196aca43637~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2d0d2955944223a93f7196aca43637~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>当我把 <code>a</code> 赋值给 <code>b</code> 的时候，相当于在内存里开辟了一个新的坑位，然后将此时此刻的 a 值拷贝了一份、塞了进去。</p><p>从这一刻开始，<strong><code>a</code> 和 <code>b</code> 各据一坑，界限分明</strong>，谁也不会再影响谁。</p><p><a class="img-fancybox" href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd10b5b86ff45cab8cf28e9211429a9~tplv-k3u1fbpfcp-watermark.image?" data-fancybox="gallery" data-caption="image.png"><img class="post-img" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd10b5b86ff45cab8cf28e9211429a9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"><span class="post-img-tip">image.png</span></a></p><p>当我修改 <code>b</code> 值的时候，相当于解除了 <code>b</code> 变量和旧的 <code>b</code> 值（也就是 <code>1</code>）之间的关联关系，然后建立了 <code>b</code> 变量和新的 <code>b</code> 值（也就是 <code>2</code>）之间的关联关系。此时 <code>b</code> 的值已经发生了变化，但 <code>a</code> 坑里的 <code>1</code> 纹丝不动。</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ebcd63effd49c0ad9a9aad5d8e99ad~tplv-k3u1fbpfcp-watermark.image?" data-fancybox="gallery" data-caption="image.png"><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ebcd63effd49c0ad9a9aad5d8e99ad~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"><span class="post-img-tip">image.png</span></a></p><p>在这整个过程中，出现的值有三个：<strong>a 值 = 1、b 值（初始值） = 1、b 值（修改后） = 2</strong>。</p><p>试想，我们能够把数字 <code>1</code> 修改为数字 <code>2</code> 吗？当然是不行的，1 就是 1，2 就是 2。我们最多只能调整数字 <code>1</code>、<code>2</code> 和变量 <code>b</code> 之间的映射关系。</p><p>也就是说，1、1、2 这三个数字<strong>从创建开始就不会再发生任何改变</strong>。</p><p>我们修改 b 值的时候，其实是在<strong>修改数字 1、2 与“b 变量”之间的关系</strong>，而并不是在修改数字本身。</p><p><strong>像数字类型这样，自创建起就无法再被修改的数据，我们称其为“不可变数据</strong>”。</p><p>对应到 JS 的数据分类上，“值类型”数据均为不可变数据。</p><p>但引用类型就没有那么好对付了。</p><p>在引用本身不变的情况下，引用所指向的内容是可以发生改变的。</p><p>请大家看下面这段代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;youhu&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>对于引用类型来说，当我把 a 对象赋值给 b 时，并不会发生“开辟一个新的 b 对象坑位、放入一份 a 对象的副本”这种事——JS 会直接把 a 的引用赋值给 b（如下图）。</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c6866721f84a1d8585b82bd5c965fb~tplv-k3u1fbpfcp-watermark.image?" data-fancybox="gallery" data-caption="image.png"><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c6866721f84a1d8585b82bd5c965fb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"><span class="post-img-tip">image.png</span></a></p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>引用类型的赋值过程，本质上是给同一块数据内容起一个新的名字。    </span></span>\n<span class="line"><span>赋值结束后，a 和 b 都会指向内存中的同一块数据。而这个数据，是可以被修改的（如下图）：</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><a class="img-fancybox" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0702eb197e44dc698d855fac378ccb3~tplv-k3u1fbpfcp-watermark.image?" data-fancybox="gallery" data-caption="image.png"><img class="post-img" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0702eb197e44dc698d855fac378ccb3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"><span class="post-img-tip">image.png</span></a></p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>`b.name` 被修改后，a、b 两个引用的指向没有发生任何变化——坑还是那个坑，但是坑里存的对象的内容却不一样了。  </span></span>\n<span class="line"><span>对于引用类型来说，我们总是可以像楼上这样，在数据被创建后，随时修改数据的内容。     </span></span>\n<span class="line"><span>**像这种创建后仍然可以被修改的数据，我们称其为“可变数据”。**</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="为什么函数式编程不喜欢可变数据" tabindex="-1">为什么函数式编程不喜欢可变数据 <a class="header-anchor" href="#为什么函数式编程不喜欢可变数据" aria-label="Permalink to &quot;为什么函数式编程不喜欢可变数据&quot;">​</a></h2><p>我们首先来看一个简单的例子。</p><h3 id="编码实例-可变数据如何-偷袭-我们的程序" tabindex="-1">编码实例：可变数据如何“偷袭”我们的程序 <a class="header-anchor" href="#编码实例-可变数据如何-偷袭-我们的程序" aria-label="Permalink to &quot;编码实例：可变数据如何“偷袭”我们的程序&quot;">​</a></h3><p>假如你和你的好兄弟老王共同维护公司的招聘网站。在基础层，老王负责开发一系列的工具函数；在业务层，你负责将基础层的工具函数进行组装，以实现具体的业务需求。</p><p>老王的写模块里有这样一个函数，它可以修改招聘需求中的“Level（层级）”信息：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changeJobLevel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">jobInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newLevelJob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jobInfo</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newLevelJob.level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> level</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newLevelJob  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>而你的模块里有这样一个函数，它可以通过检验招聘需求中的层级信息，来检验这是否是一则面向高管群体的招聘。函数编码如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isHighLevelJob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">jobInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jobInfo.level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个检验结果非常关键，它直接决定了这一条招聘需求的去向。</p><p>若 <code>isHighLevelJob()</code>判断某需求为高管需求，则此需求在发布时不会进入公司的招聘池，而是会直接被转发到猎头公司的招聘池。 相关的发布函数示意如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> releaseJobs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">jobList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jobList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isHighLevelJob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(job)){</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 转发给猎头公司</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 转发到公司内部的池子里去</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>假设现存的招聘数据中已经有这样一条需求描述：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JOB_INFO_001</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {level: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, workTime:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , type:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;engineer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, city:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;New York&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>这天你接到一个新的需求，内容是：    </span></span>\n<span class="line"><span>想要创建一条各方面条件都和 `JOB_INFO_001` 一致，但是 level 为 10 的招聘需求 `JOB_INFO_002`。随后，将 `JOB_INFO_001` 和 `JOB_INFO_002` 一起发布。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>于是你刷刷两下子，迅速组装出了这样一坨业务代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { changeJobLevel } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;老王的模块&#39;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { isHighLevelJob, releaseJobs} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;我自己的模块&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JOB_INFO_001</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {level: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, workTime:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , type:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;engineer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, city:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;New York&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 基于 JOB_INFO_001，生成一个 level 为 10 的 JOB_INFO_002</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JOB_INFO_002</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changeJobLevel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JOB_INFO_001</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组装两条数据为一个发布数组</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> releaseList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JOB_INFO_001</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JOB_INFO_002</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发布两条数据</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">releaseJobs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(releaseList, isHighLevelJob)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>一段危险的业务代码就此完工。你兴冲冲地发布上线，结果却发现酿成大错——<code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 这两条需求竟然都被转发进了猎头需求池，公司的猎头预算瞬间翻了一倍。</p><p>经过上文对值类型和引用类型特性的回顾，相信许多同学早就看出了问题的所在——<code>changeJobLevel()</code> <strong>函数直接修改了入参</strong> <code>jobInfo</code> <strong>的内容</strong>，这导致 <code>JOB_INFO_001</code> 也发生了改变。</p><p>尽管 <code>changeJobLevel()</code> 在函数的第一行就象征性地把入参赋值给了一个新的变量“<code>newLevelJob</code>”，但这并没有什么卵用——正如我们在上文所分析的那样，对于 <code>Object</code> 类型来说，这样的赋值动作仅仅是把 <code>jobInfo</code> 的引用赋值给了 <code>newLevelJob</code> ，本质上相当于给同一个对象起了两个名字。</p><p>因此，<code>changeJobLevel()</code> 函数修改 <code>newLevelJob</code>，其实就是在修改 <code>JOB_INFO_001</code>。</p><p>同理，将 <code>JOB_INFO_001</code> 以传参的形式赋值给 <code>jobInfo</code> 的过程、以及将 <code>changeJobLevel()</code> 返回的对象赋值给 <code>JOB_INFO_002</code> 的过程，也都仅仅是“取新名字”的过程。</p><p>也就是说，在整段代码中，<code>jobInfo</code>、<code>newLevelJob</code>、<code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 这四个“名字”指向的对象其实是同一个。</p><p>因此，当 <code>changeJobLevel()</code> 执行完毕时，<code>JOB_INFO_001</code> 和 <code>JOB_INFO_002</code> 是严格等于的关系，它们共同指向一条 level 为 10 的招聘需求：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35138aa17ab0439ba6cb27ec6fd43a4c~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35138aa17ab0439ba6cb27ec6fd43a4c~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>相应地，这两个变量都将会被校验为“高管需求”，并被转发至猎头需求池。</p><p>这就是一个典型的由可变数据所酿成的惨案。</p><h3 id="思考-可变数据的危险之处" tabindex="-1">思考：可变数据的危险之处 <a class="header-anchor" href="#思考-可变数据的危险之处" aria-label="Permalink to &quot;思考：可变数据的危险之处&quot;">​</a></h3><p>我们当然可以说，这个惨案是由老王一手造成的——他的函数编码不够规范，导致我们在上层的业务层进行调用时，无法达到预期的结果。</p><p>确实，老王跪了，他跪给了 JS 语言的灵活性，跪给了可变数据的不可捉摸。</p><p>他或许也曾经想过，要把外部变量和函数变量隔绝开，否则，他也没有必要在函数的第一行就重新做了一遍对象赋值。</p><p>只是，智者千虑也必有一失。他忘了，给对象穿个新马甲根本解决不了问题。如果可以，他一定会重新好好审视一遍<strong>可变数据的危险之处</strong>，那么他就会清醒地意识到，可变数据总是存在以下问题：</p><h4 id="可变数据使函数行为变得难以预测" tabindex="-1">可变数据使函数行为变得难以预测 <a class="header-anchor" href="#可变数据使函数行为变得难以预测" aria-label="Permalink to &quot;可变数据使函数行为变得难以预测&quot;">​</a></h4><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>在上面这个案例中， `isHighLevelJob()` 方法是你写的，`changeJobLevel()` 方法是隔壁老王写的。  </span></span>\n<span class="line"><span>你俩开发函数时各占用了一个分支，你本地自测如丝般顺滑，甚至老王自己的本地自测也如丝般顺滑（他很有可能只会校验 `changeJobLevel()` 本身的功能，而无法察觉到函数对外部环境的影响）。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当且仅当你们的代码一起进入主分支时，问题才会被暴露出来。  </span></span>\n<span class="line"><span>也就是说，开发者对两个函数的行为的预测，在合入主分支后就失效了。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这正是可变数据带来的最根本的问题——<strong>不确定性</strong>。</p><p>可变数据会使数据的变化变得隐蔽，进而使函数的行为变得难以预测。</p><p>在函数式编程这种范式下，我们校验一个函数有效性的关键依据，永远是“<strong>针对已知的输入，能否给出符合预期的输出</strong>”，这样的校验非常清晰、且容易实现。</p><p>而可变数据的出现则将会使函数的作用边界变得模糊，进而导致使用者、甚至开发者自身都难以预测它的行为最终会指向什么样的结果。</p><p>毫无疑问，这也会大大增加测试的难度。</p><h4 id="可变数据使函数复用成本变高" tabindex="-1">可变数据使函数复用成本变高 <a class="header-anchor" href="#可变数据使函数复用成本变高" aria-label="Permalink to &quot;可变数据使函数复用成本变高&quot;">​</a></h4><p>可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。</p><p>但很多情况下，当我们使用某一个函数的时候，我们会默认它是一个黑盒——无论是我今天去 npm 上拉下来一个第三方包，还是说我去其他业务的文件夹下借隔壁老王写的函数来用，我们关注的都是这个<strong>函数的效用、函数的输入与输出，而不会去关注它的实现细节</strong>。</p><p>就好像我们使用酸奶机之前，最多读一下说明书，而不会拆开它的壳子研究一下它装了几根电阻丝一样。</p><p>因此，我们有必要确保，这个黑盒是可靠的、受控的。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>**一个可靠、受控的黑盒，应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西**。   </span></span>\n<span class="line"><span>这就像我们往酸奶机里倒入了酵母和牛奶，只期望它能产出酸奶，而不希望它引燃旁边的烤箱一样。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要想做到这一点，就必须<strong>把可变数据从我们的函数代码里铲除干净。</strong></p><h2 id="不可变数据的本质-函数纯度的-安全帽" tabindex="-1">不可变数据的本质：函数纯度的“安全帽” <a class="header-anchor" href="#不可变数据的本质-函数纯度的-安全帽" aria-label="Permalink to &quot;不可变数据的本质：函数纯度的“安全帽”&quot;">​</a></h2><p>行文至此，大家可能已经发现了一个华点—— <strong>“可变数据”带来的这些麻烦，和“副作用”带来的麻烦，长得还挺像。</strong></p><p>实际上，在我们编写函数的过程中，“可变数据”是最容易引发副作用的因素之一。强调“不可变数据”，实际上仍然是在强调函数的纯度—— <strong>“坚持纯函数，避免副作用</strong>”，这是函数式编程的实践<strong>宗旨</strong>。</p><p>“不可变数据”正如一顶牢牢扣在我们程序员脑袋上的<strong>安全帽</strong>，它从实践的角度，对我们的编码行为作出了更加具体的约束，确保我们能够最大限度地输出纯净、安全的代码。</p><p>在下一节，我们就将更进一步地探讨不可变数据，并掌握在 JS 世界里应用不可变数据的几种主要姿势。</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',87)]))}]]);export{e as __pageData,p as default};
