import{_ as s,c as a,e as i,G as n,b as p}from"./chunks/framework.D5KJDRhN.js";const e=JSON.parse('{"title":"14 深入函数组合(Composition)思想：composepipe 是如何实现的","description":"","frontmatter":{"title":"14 深入函数组合(Composition)思想：composepipe 是如何实现的","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/14 深入函数组合(Composition)思想：composepipe 是如何实现的"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/14 深入函数组合(Composition)思想：composepipe 是如何实现的.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/14 深入函数组合(Composition)思想：composepipe 是如何实现的.md","lastUpdated":1739887664000}'),t={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},l={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.452ex"},xmlns:"http://www.w3.org/2000/svg",width:"24.887ex",height:"2.149ex",role:"img",focusable:"false",viewBox:"0 -750 11000 950","aria-hidden":"true"};const r=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/14 深入函数组合(Composition)思想：composepipe 是如何实现的.md"},[["render",function(s,e,r,h,k,c){return p(),a("div",null,[i("p",null,[i("mjx-container",t,[(p(),a("svg",l,e[0]||(e[0]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle" fill="LightPink" stroke="LightPink"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">保</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">姆</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">式</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">教</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">学</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">の</text></g></g><g data-mml-node="mstyle" fill="Pink" stroke="Pink" transform="translate(6000,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">温</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">情</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">示</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">：</text></g></g></g></g></g></g>',1)]))),e[1]||(e[1]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mstyle",{mathcolor:"LightPink"},[i("mrow",{"data-mjx-texclass":"ORD"},[i("mi",{mathvariant:"normal"},"保"),i("mi",{mathvariant:"normal"},"姆"),i("mi",{mathvariant:"normal"},"式"),i("mi",{mathvariant:"normal"},"教"),i("mi",{mathvariant:"normal"},"学"),i("mi",{mathvariant:"normal"},"の")]),i("mstyle",{mathcolor:"Pink"},[i("mrow",{"data-mjx-texclass":"ORD"},[i("mi",{mathvariant:"normal"},"温"),i("mi",{mathvariant:"normal"},"情"),i("mi",{mathvariant:"normal"},"提"),i("mi",{mathvariant:"normal"},"示"),i("mi",null,"：")])])])])],-1))])]),e[2]||(e[2]=n('<p>徒手编码 compose/pipe，是当下前端面试考察函数式编程的最通用、最高频 code test 题目。</p><p>任何涉及到“函数”、“组合”、“串联”、“管道”等字眼的面试题，多少都需要大家往这方面联想一下。</p><p>相关的提问姿势包括但不限于：</p><p>“如何 pipe 一系列的指定函数？”</p><p>“函数组合（compose）是一个什么样的过程？”</p><p>“rambda（或者任何一个函数式编程库）中的 compose/pipe 是如何实现的？”</p><p>“Redux 中间件是如何串联的？”</p><p>等等等等.......</p><p>不夸张地说，这是一门背也要背下来的学问。</p><p>它至少可以帮你向面试官证明，你真的能够实战函数式编程，而不是只会记忆几个 lodash-fp 或 React Hook 的 API。</p><p>如果你的时间有限，不允许你细嚼慢咽整本小册覆盖的所有知识点，请你至少把握住这一节——在面试场景下，它将助你摆脱“函数式小白”的标签。</p><h2 id="借助-reduce-推导函数组合" tabindex="-1">借助 reduce 推导函数组合 <a class="header-anchor" href="#借助-reduce-推导函数组合" aria-label="Permalink to &quot;借助 reduce 推导函数组合&quot;">​</a></h2><p>事已至此，让我们重新审视一遍 reduce 的工作流示意：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2577e6fee64879b03dce5b053a3ddf~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2577e6fee64879b03dce5b053a3ddf~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>在<a href="https://juejin.cn/book/7173591403639865377/section/7175422666629709884" target="_blank" rel="noreferrer">第12节</a>的末尾，我曾经这样疯狂暗示了大家一波：</p><blockquote><p>咱就是说，有没有可能，有没有可能咱们把 pipeline 里的每一个函数也弄成不一样的呢？</p></blockquote><blockquote><p>更直白地说，你<code> reduce() </code>既然都能组合参数了，你能不能帮我的 pipeline 组合一下函数呢？</p></blockquote><blockquote><p>毕竟，JS 的函数是可以作为参数传递的嘛！</p></blockquote><p>一旦我们能做到这一点——一旦我们可以把 reduce pipeline 里的最小计算单元修改成任意不同的函数，那么这个工作流就会变成下面这样了：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0eed4a85a54046b0c8ee9e7ef679ed~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0eed4a85a54046b0c8ee9e7ef679ed~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>这个流程，恰恰就是一个函数组合的 pipeline。</p><p>也就是说，只要我们能够想办法<strong>让 reduce 工作流里的计算单元从一个函数转变为 N 个函数</strong>，我们<strong>就可以达到函数组合的目的</strong>。</p><p>大家知道，在整个 reduce 的工作流中，callback 是锁死的，但每次调用 callback 时传入的参数是动态可变的（如下图）。</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5509a0c9e04d8f8cc7a417ccb19ccc~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5509a0c9e04d8f8cc7a417ccb19ccc~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>这些动态可变的参数，来自 reduce 的宿主数组。</p><p>之前介绍 reduce 时，我们用了一个塞满数字的数组作为示例。</p><p>但其实，数组的元素可以是任何类型——包括<strong>函数</strong>类型。</p><p>我们把<strong>待组合的函数放进一个数组里，然后调用这个函数数组的 reduce 方法</strong>，就可以创建一个多个函数组成的工作流。</p><p>而这，正是市面上主流的函数式库实现 compose/pipe 函数的思路。</p><h2 id="借助-reduce-推导-pipe" tabindex="-1">借助 reduce 推导 pipe <a class="header-anchor" href="#借助-reduce-推导-pipe" aria-label="Permalink to &quot;借助 reduce 推导 pipe&quot;">​</a></h2><p>顺着这个思路，我们来考虑这样一个函数数组：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> funcs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [func1, func2, func3]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们假设三个 func 均是用于数学计算的函数，整个工作流的任务就是吃进一个数字 0 作为入参、吐出一个计算结果作为出参。</p><p>我想要逐步地组合调用 funcs 数组里的函数，得到一个这样的声明式数据流：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9a8c25da8e44fcab4ab393e40a6a49~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9a8c25da8e44fcab4ab393e40a6a49~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>如果我借助了 reduce，我得到的数据流乍一看和楼上是有出入的：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc6e25ab292b433389d99280058d169b~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc6e25ab292b433389d99280058d169b~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>如何通过调整 reduce 的调用，使它的工作流和声明式数据流看齐呢？</p><p>首先是入参的对齐，这个比较简单，我们只需要把 initialValue 设定为 0 就可以了。</p><p>入参明确后，我的 reduce 调用长这样：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> funcs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [func1, func2, func3]  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">funs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接下来重点在于 callback 怎么实现。其实我们只需要把楼上两张图放在一起做个对比，答案就呼之欲出了：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71658f7803864aa999f8e33370b5e93f~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71658f7803864aa999f8e33370b5e93f~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>图中我用红笔对 reduce 流程做了拆分，用蓝笔对目标数据流做了拆分。</p><p>想要让上下两个流程等价，我们只需要确保红蓝两个圈圈的工作内容总是等价就可以了。</p><p>从第一对红蓝圈圈开始看起，蓝色圈圈的工作内容是 func1(0)，红色圈圈的工作内容是 callback(0, func1)。</p><p>两者等价，意味着 callback(0, func1) = func1(0)。</p><p>同理，我们可以逐步推导出第二个、第三个红色圈圈的工作内容，分别应该满足：</p><p>callback(value1, func2) = func2(value1)</p><p>callback(value2, func3) = func3(value2)</p><p>以此类推，对于任意的入参 (input, func），callback 都应该满足：</p><p>callback(input, func) = func(input)</p><p>推导至此，我们就得到了 callback 的实现：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">funcs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>再稍微包装一下，给这坨逻辑起一个新名字：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">funcs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> funcs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback,param)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>我们就得到了一个经典的 pipe 函数。</p><h2 id="验证-pipe-串联数字计算逻辑" tabindex="-1">验证 pipe：串联数字计算逻辑 <a class="header-anchor" href="#验证-pipe-串联数字计算逻辑" aria-label="Permalink to &quot;验证 pipe：串联数字计算逻辑&quot;">​</a></h2><p>长得帅的同学想必都还记得这三个函数：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> multiply3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> divide2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>问：如何基于这些独立函数，构建一个多个函数串行执行的工作流？</p><p>现在有了 pipe，我们可以轻松达到这个目的。只需要把这些函数放进一个数组里，再把数组放进 pipe 里：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> compute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([add4, multiply3, divide2])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如此，我们便能够得到一个 compute 的函数，该函数正是 add4, multiply3, divide2 这三个函数的“合体”版本。</p><p>接下来直接调用 compute() 函数，就可以开动“传送带”，得到目标的计算结果了：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 21</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>美中不足的是手动构造数组有点麻烦，我们可以直接使用展开符来获取数组格式的 pipe 参数：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用展开符来获取数组格式的 pipe 参数</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">funcs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> funcs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback,param)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>由此我们就可以向 pipe 传入任意多的函数，组合任意长的函数工作流了：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> funcFlow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(method1, method2, method3, method4,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">., methodN)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>至此，我们便实现了一个通用的 pipe 函数。</p><h2 id="compose-倒序的-pipe" tabindex="-1">compose：倒序的 pipe <a class="header-anchor" href="#compose-倒序的-pipe" aria-label="Permalink to &quot;compose：倒序的 pipe&quot;">​</a></h2><p>pipe 用于创建一个正序的函数传送带，而 compose 则用于创建一个倒序的函数传送带。</p><p>我们把 pipe 函数里的 reduce 替换为 reduceRight，就能够得到一个 compose：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用展开符来获取数组格式的 pipe 参数</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">funcs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> funcs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduceRight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback,param)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>使用 compose 创建同样的一个函数工作流，我们需要把入参倒序传递，如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> compute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(divide2, multiply3, add4)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>组合后的流水线顺序，和传参的顺序是相反的。也就是说执行 compute 时，函数的执行顺序是这样的：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/361ab5f915a446db8db433f60996bd92~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/361ab5f915a446db8db433f60996bd92~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p><strong>正序是 pipe，倒序是 compose。</strong></p><p>pipe 和 compose 的辨析，本身也是一个热门的考察点。在面试场景下，大家一定要听清楚面试官的要求，写代码前先确认需求是【<strong>Pipe--&gt;</strong> 】一系列函数还是【<strong>Compose&lt;--</strong>】一系列函数。</p><blockquote><p>作者注：为什么 pipe 是正序，compose 是倒序？关于这个问题，我们在 <a href="https://juejin.cn/book/7173591403639865377/section/7175422979646423098" target="_blank" rel="noreferrer">第17节</a>还有更进一步的讨论，感兴趣的同学可以关注第17节的“复合运算：范畴论在编程中最核心的应用”这个section</p></blockquote><h2 id="知其所以然-why-compose" tabindex="-1">知其所以然：Why Compose? <a class="header-anchor" href="#知其所以然-why-compose" aria-label="Permalink to &quot;知其所以然：Why Compose?&quot;">​</a></h2><p>面向对象的核心在于继承，而<strong>函数式编程的核心则在于组合</strong>。</p><p>我们常说函数式编程就像一个乐高游戏：那一个个独立内聚的函数就像一堆乐高积木方块儿。它们看似渺小到无足轻重，却可以在<strong>组合</strong>后变幻出千百种形态、最终呈现出复杂而强大的功能。</p><p>组合这个动词，赋予了函数式编程无限的想象力和可能性。</p><p>在函数式编程的实践中，我们正是<strong>借助 compose 来组合多个函数的功能</strong>，它<strong>是函数式编程中最有代表性的一个工具函数</strong>，所以它才会成为面试题中的常客。</p><p>在编码层面，如果不喜欢 reduce，你还可以借助循环、递归等姿势来实现 compose。</p><p>这里我选取了 reduce，一方面是因为它足够主流（市面流行的函数式编程库 ramda 也采取了基于 reduce 的实现），另一方面也是因为它足够巧妙。</p><p>巧妙到什么程度呢？结合个人的经验来看，在实际的编码和面试中，基于 reduce 的 compose 几乎是理解成本最高、同时也是许多同学避之不及的一个版本。</p><p>许多能力是可以向下兼容的，包括 compose 的实现。</p><p>我相信对多数同学来说，读懂一段循环代码或者递归代码都不会是特别难的事情。</p><p>然而，如果你之前没有刻意练习过从 reduce 到 compose 的推导过程，那么第一次见到类似代码的时候，即便能够勉强理解代码的意图，也未必能够灵机一动把眼前的 reduce 调用和函数组合联系起来。</p><p>但经过了近几节的学习，相信大家早已对 reduce 刮目相看了。</p><p>当你再次在别人写的代码中见到 reduce 时，脑海中闪现的关键字除了“数组、斐波那契”等等之外，不要忘了还有“<strong>函数组合</strong>”。</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',96))])}]]);export{e as __pageData,r as default};
