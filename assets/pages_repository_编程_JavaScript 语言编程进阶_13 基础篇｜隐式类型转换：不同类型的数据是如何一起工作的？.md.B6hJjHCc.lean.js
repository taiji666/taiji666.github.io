import{_ as s,c as i,G as a,b as n}from"./chunks/framework.D5KJDRhN.js";const e=JSON.parse('{"title":"13 基础篇｜隐式类型转换：不同类型的数据是如何一起工作的？","description":"","frontmatter":{"title":"13 基础篇｜隐式类型转换：不同类型的数据是如何一起工作的？","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 语言编程进阶"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 语言编程进阶/13 基础篇｜隐式类型转换：不同类型的数据是如何一起工作的？"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 语言编程进阶/13 基础篇｜隐式类型转换：不同类型的数据是如何一起工作的？.md","filePath":"pages/repository/编程/JavaScript 语言编程进阶/13 基础篇｜隐式类型转换：不同类型的数据是如何一起工作的？.md","lastUpdated":1739887664000}');const p=s({name:"pages/repository/编程/JavaScript 语言编程进阶/13 基础篇｜隐式类型转换：不同类型的数据是如何一起工作的？.md"},[["render",function(s,e,p,l,t,h){return n(),i("div",null,e[0]||(e[0]=[a('<p>这一章我们来学习隐式类型转换。为什么要加上<code>隐式</code>二字呢？因为隐式往往限定了具体的场景，有着明确规定的转换规则，比如加法运算。如果不加这两个字，那么比如把一个对象转换成字符串，可以是 String(obj)，也可以是 obj.toString()，这是两种不一致的逻辑。</p><p>类型的隐式转换常常不被重视，很多人对具体场景的理解往往是想当然的，从而产生一些非预期的结果，甚至是运行时异常。接下来，我就列举几种常见的涉及类型转换的案例，和大家一起深究背后的逻辑。</p><h2 id="模板字符串-template-literals" tabindex="-1">模板字符串（Template literals） <a class="header-anchor" href="#模板字符串-template-literals" aria-label="Permalink to &quot;模板字符串（Template literals）&quot;">​</a></h2><p>模板字符串是这种带<code>占位符</code>的字符串，并且可以声明成带换行符的<code>多行</code>字符串。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Hello!</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>既然是字符串，那么上面的占位符变量 name 自然需要转换成字符串类型。</p><p>一般的对象，如果原型链上够上溯到 <code>Object.prototype</code>，那么就可以调用 <code>toString()</code> 实例函数。有的对象会重载这个函数，比如 Date，甚至像 Number 的 toString 还带有一个参数。如果没有重载，相当于：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [object xxx]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>但是在模板字符串中，并不是调用变量的 <code>toString</code> 方法，这样不安全，毕竟变量可能不是广义上的对象（null、undefined），而且 toString 也可以被重载为不返回字符串类型。</p><p>这里就要用到 ECMAScript 规范定义的一个内部函数了，叫做 <code>ToString()</code>。没错，规范已经盘点好了各种类型转换的需求，其他的还有 ToBoolean、ToNumber、ToObject，甚至还有一些场景化的转换，比如 ToLength、ToPropertyKey、ToIndex，还有一个相当重要的 <code>ToPrimitive</code>，我们马上讲到。</p><p>言归正传，我们看 <code>ToString(arg)</code> 是如何工作的。</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 判断入参类型，遍历一遍所有的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`Primitive`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 类型：</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是 String，显然不用转换，直接返回；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是 Symbol，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`抛出异常`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，这个我们在 Symbol 那一章讲过，除非调用 Symbol 实例的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`toString()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 方法，否则不可以转换成字符串；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是 Undefined，就返回 “undefined”；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是 Null，就返回 “null”；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是 Boolean，就返回 “true” 或 “false”；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是 Number 或者 BigInt，都转换成其 10 进制表示形式，这里面的细节不涉及类型转换，所以我们就不深究了，大家注意这里可能输出“NaN”、“Infinite”和科学记数法。</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果是非 Primitive 类型，也就是 Object，如何转换成字符串呢？答案是将参数带入到 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`ToPrimitive(arg, string)`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>ToPrimitive(input[, preferredType])</code> 用来将参数转换成 <code>Primitive</code> 类型，即非 Object。</p><p>通常来说，使用到 ToPrimitive 的场景，都是在参数已经被判定是 Object 的条件之下。下面我们也以此为前提条件来梳理它的原理。</p><p>首先来看它的第二个参数 <code>preferredType</code>，它是可选的，如果传入，只能是 &quot;string&quot; 或者 “number” 这两个值。想必你已经猜到了，<code>preferredType</code> 就是用来控制对象是偏向转换成哪种 Primitive 类型的。虽然它只能取值为数字和字符串，但并不限制 ToPrimitive 返回其他类型。</p><p><code>ToPrimitive</code> 会先尝试取对象的一个方法，叫做 <code>[Symbol.toPrimitive]</code>。没错，又是 Symbol 预设常量的应用场景。</p><p>这个方法存在于对象本身或者原型链都可以，像下面这两种声明方式都是允许的：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [Symbol.toPrimitive](</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hint</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;number&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [Symbol.toPrimitive](</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hint</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;number&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>它的参数 <code>hint</code> 事实上就是 <code>preferredType</code>：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> preferredType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>因此，<code>Symbol.toPrimitive</code> 的引入相当于把内部方法 <code>ToPrimitive</code> 外包给了开发者去定义。<code>ToString</code> 在调用 <code>ToPrimitive</code> 的时候，<code>preferredType</code> 用的是 “string”，因此下面的 <code>hint</code> 就是 “string”：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [Symbol.toPrimitive](</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hint) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;number&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 67</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;foo&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// “foo”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>什么时候 <code>hint</code> 会是 “number” 呢？别急，马上就会讲到了。</p></blockquote><p>注意，<code>[Symbol.toPrimitive]</code> 必须返回一个 Primitive 类型，如果不是的话，就会抛出异常。在 <code>ToString</code> 的场景下，该返回值还会递归传入到 <code>ToString</code>，确保最终生成一个字符串。</p><p>如果对象没有 <code>[Symbol.toPrimitive]</code> 方法，那么就会回退到没有 ES6 之前的逻辑。在这个逻辑中，<code>不传递 preferredType 不代表是 “default”，而是 “number”</code>，即 ToPrimitive 倾向于返回数字类型。</p><p>但是没有 <code>[Symbol.toPrimitive]</code> 的话，<code>preferredType</code> 还有什么用呢？有，这里就要调用另一个内部方法了，叫做 <code>OrdinaryToPrimitive(O, preferredType)</code>。</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`OrdinaryToPrimitive`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 中，逻辑是这样的：</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`preferredType`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 等于 “string”，那么就会尝试依次调用对象的 toString 和 valueOf 方法，如果 toString 存在就不会调用 valueOf；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`preferredType`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 等于 “number”，那么就会尝试依次调用对象的 valueOf 和 toString 方法，如果 valueOf 存在就不会调用 toString；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果返回值不是 Primitive 类型，抛出异常。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>是不是很有意思？都是在尝试使用 toString 和 valueOf 的返回值作为 Primitive 类型，只不过根据 <code>preferredType</code> 的值不同，调用顺序不同而已。</p><p>对于一般的对象来说，其 toString 和 valueOf 都会上溯到原型对象 <code>Object.prototype</code> 中。</p><p>也就是说，绕来绕去，<code>ToString(O)</code> 最终还是在调用 <code>O.toString()</code>，或者 <code>Object.prototype.toString.call(O)</code>。</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">既然还没到底，那我们就继续深挖，来看 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`Object.prototype.toString`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 逻辑：</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果对象定义了 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`Symbol.toStringtTag`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 属性，设为 tag，返回 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[object ${tag}]`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 根据类型不同，返回 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[object Undefined/Null/Array/Arguments/Function/Error/Boolean/Number/String/Date/RegExp/Object]`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可见，又有一个 Symbol 的常量被使用，到此为止，我们才遍历完了所有 Symbol 常量的应用场景，但我相信未来 ECMAScript 规范还会继续引入新的常量。</p><p>这个方法几乎能分辨所有我们日常想要区分的类型，简直比 <code>typeof</code> 还好用。但是用作对象转换字符串的结果，其返回值格式还是偏死板，其中的 <code>[object Object]</code> 应该是很多同学都经历过的打印噩梦。</p><p>事实上，很多规范内置的对象类型，都对 toString 进行了重载，比如 Number、BigInt、Array、Error、Symbol、RegExp、Boolean、Date。因此，它们转换成字符串的时候，压根走不到 <code>Object.prototype.toString</code>。</p><p>另外像 JSON、Math、Atomics、Reflect、Map、Set、Symbol、WeakMap、WeakRef、Promise 等等很多对象，还有浏览器环境的 window 和 document，也都定义了自己的 <code>[Symbol.toStringTag]</code> 属性，因此在 <code>Object.prototype.toString</code> 下也有定制化的返回结果，大家不妨试一试：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Math)</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window)</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>相比之下，<code>Object.prototype.valueOf</code> 就简单多了，就返回对象自身。不过像 Date、Symbol、Number、String、Boolean 都重载了这个函数，返回的都是 Primitive 类型，比如：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1686978276206</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;x&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// symbol(x) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">56</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 56</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;&#39;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>到此为止，我才终于把 <code>ToPrimitive</code> 的完整逻辑讲完，相信绝大多数同学的感受都是看着越来越懵😳。那不妨用一张图来辅助理解吧：</p><p><a class="img-fancybox" href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d31c5a1aed4a86ab3b71e98f982eb6~tplv-k3u1fbpfcp-watermark.image?" data-fancybox="gallery" data-caption="image.png"><img class="post-img" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d31c5a1aed4a86ab3b71e98f982eb6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"><span class="post-img-tip">image.png</span></a></p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">再把它代入到 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`ToString`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 中，我们大概就能推理出在</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`模板字符串`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">之下，想要控制一个对象的字符串表示形式，可以有这么几种方式：</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 定义 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[Symbol.toPrimitive]()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 方法；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 重载 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`toString()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 方法；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果对象（包括原型链）没有 toString，那么定义 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[Symbol.toStringTag]`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 也能控制，只不过只能是 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`[object ${tag}]`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的格式；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果对象（包括原型链）没有 toString，那么定义 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`valueOf`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 也有效。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>💡 后两种情况比较少，一般需要 <code>Object.create(null)</code> 来断开与 <code>Object.prototype</code> 的关系。</p></blockquote><p>以上就是模板字符串中的变量隐式转换逻辑，顺带着我们也理清了在对象上调用 <code>toString</code> 可能会走的逻辑。那么，还有一种把变量转换成字符串的方法是利用 String 的强制转换：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vari)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这个情况的原理也比较简单：</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如果入参是 Symbol 类型，单独走一个叫做 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`SymbolDescriptiveString()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的方法，生成类似 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`Symbol(xxx)`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的格式；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 其他类型的话，都走 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`ToString()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个算法相当于避开了 <code>vari.toString()</code> 在 null、undefined 或者对象没有 toString 情况导致的报错问题，也规避了模板字符串中调用 <code>ToString()</code> 从而不兼容 Symbol 导致的报错问题，是最安全的一种字符串转换方法。</p><p>不过无论哪种方法，如果你自定义的 <code>[Symbol.toPrimitive]</code>、<code>[Symbol.toStringTag]</code>、<code>toString</code> 等等不够健壮，依然是可能在格式转换时报错的。</p><h2 id="加法运算" tabindex="-1">加法运算（+） <a class="header-anchor" href="#加法运算" aria-label="Permalink to &quot;加法运算（+）&quot;">​</a></h2><p>对于 JavaScript 这种动态语言来说，运行时需要处理的类型转换工作非常常见，<code>toPrimitive</code> 在特别多的地方都有所用。现在我们来看另一种常见的操作：加法运算（Addition Operator）。</p><p>为什么要单独讲加法，而不是减法、乘法、除法？因为其他运算一定都是数学运算，参与的变量一定都要转换成数字才可以。而加法存在歧义性，它可能是数学运算，也可能只是字符串拼接，所以最关键的是要判断什么时候是哪种操作。</p><p>假设计算 <code>A+B</code>，操作如下：</p><p>首先，两者都转换 Primitive 类型，<code>a=ToPrimitive(A)</code>、<code>b=ToPrimitive(B)</code>，注意没有传入 <code>preferredType</code> 参数，如果你定义了 <code>[Symbol.toPrimitive]</code> 函数，参数 <code>hint</code> 就会是 <strong>default</strong>；如果没有定义 <code>[Symbol.toPrimitive]</code>，<code>preferredType</code> 就默认是 <strong>number</strong>，从而会先尝试调用 valueOf，没有才会调用 toString。不妨验证一下。</p><p>下面一段可以验证调用了 <code>ToPrimitive</code>，并且 <code>hint</code> 为 “default”：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [Symbol.toPrimitive](</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hint); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;default&quot;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这一段代码则可证明 <code>preferredType</code> 默认为 “number”，进而优先调用了 <code>valueOf</code>：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;valueOf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// valueOf</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;toString&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>好，我们继续加法的运算，在得到了 a 和 b 这两个 Primitive 类型之后，判断它们之中有没有 String 类型，如果有，则认为这个运算属于字符串拼接，把 a 和 b 传入 <code>ToString</code>。</p><p>我们可以想象这一步可能发生什么。如果 a 和 b 之间任意一个是 Symbol 类型，那么加法执行到 <code>ToString</code> 这一步则必报错。</p><p>如果 a 和 b 都不是 String，那么这个加法就属于数学运算，它们两个要继续转换成数字，调用内部方法 <code>ToNumeric</code>。受限于篇幅，我就不在这里展开了，需要特别强调的是，数字也分成 Number 和 BigInt，它们二者是不可以相加的。</p><p align="center"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b642088cf652467398919ffaa3eb9a00~tplv-k3u1fbpfcp-watermark.image" width="70%"></p><p>以上就是 JavaScript 中加法的主要逻辑，这么一看还算简单，现在我们看一个更复杂一点的操作。</p><h2 id="相等判断" tabindex="-1">相等判断（==） <a class="header-anchor" href="#相等判断" aria-label="Permalink to &quot;相等判断（==）&quot;">​</a></h2><p>之前提到过内部的 <code>IsStrictlyEqual</code> 方法，它代表的是 <code>===</code> 操作符，逻辑还是很简单的，毕竟只要类型不同，就一定返回 false。</p><p><code>==</code> 不然，它在比较不同类型数据的时候，是允许返回 true 的，因此要比 <code>===</code> 有更多的特例。</p><p>它在规范内部由方法 <code>IsLooselyEqual</code> 代表，我们来分析它的原理，以 <code>A == B</code> 为例。</p><p>第一步，判断 A 和 B 的类型，如果相同，则转 <code>IsStrictlyEqual(A, B)</code>，可见如果类型相同，<code>==</code> 与 <code>===</code> 是等价的。</p><p>接下来，如果 A 和 B，一个是 null，一个是 undefined，那么返回 true，即 <code>null == undefined</code>；如果其中一个是 <code>document.all</code>，另一个是 null 或者 undefined，返回 true。在前面<a href="https://juejin.cn/book/7226969813581889575/section/7231458326247112737" target="_blank" rel="noreferrer">“如何判断变量的类型”</a>那一章我们就讲到过 <code>document.all</code> 的特殊之处，在这里也有效果：<code>document.all == null</code>，<code>document.all == undefined</code>。</p><p>如果 A 和 B，一个是 String，一个是 Number，那么把 String 传入 <code>toNumber()</code>，再和另一边共同传入 <code>IsLooselyEqual</code>。也就是说，<strong>字符串和数字比较，是把字符串转换成数字，而不是把数字转换成字符串</strong>。以下代码可以作证：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;0xF&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;0b11&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在一个是 String、一个是 BigInt 的情况下，也是同样的操作，都是 String 被转换。</p><p>继续，如果 A 和 B 有一方是 Boolean，那么就把它转成数字，结果无非是 1 或者 0，然后继续递归用 <code>IsLooselyEqual</code>比较：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;0x1&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果 A 和 B 有一方是 Object，那么会把这个对象用 <code>ToPrimitive</code> 转换，再继续递归比较。注意，这里必须只有<strong>一方</strong>是 Object，如果双方都是，就会走到前面的 <code>IsStrictlyEqual</code> 分支去了。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>最后，如果双方分别是 Number 和 BigInt，那么就比较它们的数值（mathematical value）是否相等。</p><p>其他情况，都返回 false。以上就是 <code>==</code> 的全部逻辑。想必大家看过后会觉得比 <code>ToPrimitive</code> 还要迷茫，这样做真的能覆盖所有场景吗？</p><p>我帮大家理一理这个逻辑。ECMAScript 一共定义了 Undefined、Null、Boolean、Number、BigInt、Symbol、String、Object 这 8 种类型，按理说 <code>==</code> 需要兼顾到这 8 种的排列组合。但是实际上可以大大简化，我们看：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. **Object 在比较的时候，总会转换成 Primitive，因此可以去掉 Object；**</span></span>\n<span class="line"><span>2. **Boolean 在比较的时候，总会转换成 Nummber，因此可以去掉 Boolean；**</span></span>\n<span class="line"><span>3. **Undefined 和 Null 只有互相比较的时候返回 true，和其他任意类型都返回 false，因此也可以去掉 Null、Undefined；**</span></span>\n<span class="line"><span>4. **Symbol 和任意类型比较都返回 false，因此还可以去掉 Symbol。**</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后我们就剩 String、Number、BigInt 这三种类型了，而后两者还可以归结为 Numeric。String 在和 Numeric 比较的时候，总会尝试把自身转换为对方的类型，而 Numeric 内部的 Number 和 BigInt 之间的比较又会看数值。</p><p>这就是 <code>==</code> 简化后的东西了，<strong><code>就是 String 和 Numeric 而已</code></strong>。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本章节我们梳理了模板字符串、加法（+）和相等判断（==）这三种操作的背后逻辑，这只是 ECMAScript 众多操作中的冰山一角。但我想表达的是，在这种动态语言中，变量的隐式类型转换应该是常态，如果你实现了一个函数，除非有类型辅助系统（如 TypeScript）的帮助，那么就不能假设入参一定就是你期望的类型，应该要学会进行自动转换。</p><p>不过，类型转换的背后也会涉及到众多的策略差异，比如 <code>${name}</code> 和 <code>String(name)</code> 就有所不同，从而产生不一样的结果，甚至报错。</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">我给到大家的建议就是，牢记常见的类型转换手段，以及背后的原理，比如：</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 任意类型转换成字符串（本文已全部涉及）；</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 字符串转换成数字，比如 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`+foo`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`parseInt(foo)`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`foo | 0`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 等。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此外，像 <code>ToPrimitive</code>、<code>ToString</code> 这类规范内部的方法，大家也应该有所掌握，它们之间的组合往往就是一种运算、操作的核心原理。</p><p>到此为止，本小册的基础篇就结束了。熟练掌握基础篇的内容，能够让你在应付日常业务开发的活动中更有深度思考，进而能减少编写漏洞代码的数量。但是如果编写通用型模块、底层框架，那么还需要掌握更高级的内容。</p><p>接下来，就让我们开启进阶篇吧！</p>',87)]))}]]);export{e as __pageData,p as default};
