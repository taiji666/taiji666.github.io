import{_ as s,c as a,G as n,b as i}from"./chunks/framework.D5KJDRhN.js";const p=JSON.parse('{"title":"9 思考：持久化数据结构，是 Immutability 的唯一答案吗？","description":"","frontmatter":{"title":"9 思考：持久化数据结构，是 Immutability 的唯一答案吗？","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/9 思考：持久化数据结构，是 Immutability 的唯一答案吗？"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/9 思考：持久化数据结构，是 Immutability 的唯一答案吗？.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/9 思考：持久化数据结构，是 Immutability 的唯一答案吗？.md","lastUpdated":1739887664000}');const e=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/9 思考：持久化数据结构，是 Immutability 的唯一答案吗？.md"},[["render",function(s,p,e,l,r,t){return i(),a("div",null,p[0]||(p[0]=[n('<h2 id="react-与函数式编程" tabindex="-1">React 与函数式编程 <a class="header-anchor" href="#react-与函数式编程" aria-label="Permalink to &quot;React 与函数式编程&quot;">​</a></h2><p>我所在的团队使用 React 作为主要技术栈已经有超过五年的时间了。因此，我们在招聘前端工程师时会格外注意 React 能力的考察。</p><p>而 React，它生来自带函数式光环。</p><p>无论是<code> UI = f(data) </code>的宏观设计，还是 <code>setState</code> API 对“不可变值”的预期，抑或是好基友 Redux 中以纯函数形态存在的 <code>reducer</code>...... 这些无一不彰显着它和函数式思想的暧昧关系。</p><p>当然，不得不提的还有随着 React16+ 逐渐普及开来的函数式组件+ Hooks 等等。</p><blockquote><p>函数式编程对现代前端框架、对前端生态的影响，我们在小册的后半程会单开章节来讨论。此处不多赘述。</p></blockquote><p>我相信，对许多前端工程师来说，React 才是大家入门函数式思想的起点。</p><p>也正因为如此，我们非常喜欢在 React 系列的问题结束后，和候选人聊一聊函数式编程。</p><h2 id="关于-immutablility-不可变性-的刻板印象" tabindex="-1">关于 Immutablility（不可变性） 的刻板印象 <a class="header-anchor" href="#关于-immutablility-不可变性-的刻板印象" aria-label="Permalink to &quot;关于 Immutablility（不可变性） 的刻板印象&quot;">​</a></h2><p>在许多团队的函数式编程题库里，“数据不可变性如何在前端业务中落地”都是一道高频考题。</p><p>遗憾的是，这道题目的答案多年来也几乎是“固定”的，八成左右的候选人的答案都有且仅有一个——Immutable.js/持久化数据结构。</p><p>如果是在 2016 年，这个答案确实足以成为问题的终点。</p><p>但在今天，很多时候面试官们会忍不住追问：Immutable.js/持久化数据结构是唯一的答案吗？</p><p>不少同学仍然会回答“是”，尽管这个“是”里夹带了那么些许的不确定，但它足以反映社区对 Immutability 的刻板印象。</p><p>这一节我希望大家学到的东西，就是如何对这个问题说“不”。</p><p>Immutable.js 对于前端函数式编程来说，有划时代的意义。许多同学正是通过它才了解到“不可变数据”、“持久化数据结构”等概念。</p><p>但它终究也只是实现 Immutability 的一种途径。在活跃的函数式社区中，优秀的 Immutability 实践还有很多——比如，Immer.js。</p><h2 id="immer-js-一个傻瓜式的-immutability-解决方案" tabindex="-1">Immer.js，一个傻瓜式的 Immutability 解决方案 <a class="header-anchor" href="#immer-js-一个傻瓜式的-immutability-解决方案" aria-label="Permalink to &quot;Immer.js，一个傻瓜式的 Immutability 解决方案&quot;">​</a></h2><p>Immer.js 是我在 2019 年最喜欢的前端库之一。在理解了 Immer.js 的设计思想和工作方式之后，我将团队主要仓库的不可变数据的解决方案全部从 Immutable.js 迭代为了 Immer.js。</p><p>作为一个实用主义者，我至今没有后悔这个决定。</p><p>因为用 Immer.js 写代码，真的是太爽啦！(<em>^▽^</em>)</p><p>不需要操心深拷贝浅拷贝的事儿，更不需要背诵记忆 Immutable.js 定义的一大堆 API，你所需要做的，仅仅是在项目里轻轻地 Import 一个 produce（请看下文代码，解析在注释里）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> produce </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;immer&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这是我的源数据</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> baseState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;修言&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">99</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;秀妍&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义数据的写逻辑</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> recipe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> draft</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    draft.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;xiuyan&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">101</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    draft[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 102</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 借助 produce，执行数据的写逻辑</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(baseState, recipe)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>这个 API 里有几个要素：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   (base)state：源数据，是我们想要修改的目标数据</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   recipe：一个函数，我们可以在其中描述数据的写逻辑</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   draft：recipe 函数的默认入参，它是对源数据的代理，我们可以把想要应用在源数据的变更应用在 draft 上</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   produce：入口函数，它负责把上述要素串起来。具体逻辑请看下文分解。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>记住上述要素的基本特性，我们接下来要冲一波源码了xdm！</p><h2 id="immer-js-是如何工作的" tabindex="-1">Immer.js 是如何工作的 <a class="header-anchor" href="#immer-js-是如何工作的" aria-label="Permalink to &quot;Immer.js 是如何工作的&quot;">​</a></h2><p>Immer.js 实现 Immutability 的姿势非常有趣——它使用 Proxy，对目标对象的行为进行“元编程”。</p><h3 id="回顾-proxy" tabindex="-1">回顾 Proxy <a class="header-anchor" href="#回顾-proxy" aria-label="Permalink to &quot;回顾 Proxy&quot;">​</a></h3><p>Proxy 是 ES6 中引入的一个概念。这里为了确保所有知识层次的同学都具备足够清晰的上下文，我们先快速地对 Proxy 相关的要点做一个回顾。</p><blockquote><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 ——MDN</p></blockquote><p>Proxy 是 JS 语言中少有的“元编程”工具。</p><p>所谓“元编程”，指的是对编程语言进行再定义。</p><p>借助 ES6 暴露给我们的 Proxy 构造函数，我们可以创建一个 Proxy 实例，并借助这个实例对目标对象的一些行为进行再定义。</p><p>举个例子（解析在注释里）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义一个 programmer 对象</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> programmer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义这个对象的拦截逻辑</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxyHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // obj 是目标对象， key 是被访问的键名</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj[key]</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 借助 Proxy，将这个对象使用拦截逻辑包起来</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrappedProgrammer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(programmer, proxyHandler)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;xiuyan&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wrappedProgrammer.name)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 100</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wrappedProgrammer.age)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>如这段代码所示， Proxy 接收两个参数，第一个参数是你需要处理的目标对象，第二个参数同样是一个对象，在这个对象里，描述了你希望对目标对象应用的拦截/代理行为。</p><p>在这个例子里，我借助 <code>proxyHandler</code> 拦截了目标对象（<code>programmer</code>）的 <code>getter</code> 方法，代理了 <code>programmer</code> 对象的访问行为。</p><p>每次访问 <code>wrappedProgrammer</code> 时，JS 不会执行 <code>programmer</code> 对象的默认行为（返回 <code>obj[key]</code>），而是会执行 <code>proxyHandler.get()</code> 方法所定义的行为：若访问的 key 是 <code>age</code>，则固定返回 100，否则返回 <code>obj[key]</code>。</p><p>（同理，我们也可以对目标对象的 <code>setter</code> 方法进行拦截，此处不再赘述）。</p><p>总结一下：借助 Proxy，我们可以给目标对象创建一个代理（拦截）层、拦截原生对象的某些默认行为，进而实现对目标行为的自定义。</p><p>那么 Proxy 是如何帮助 Immer.js 实现 Immutability 的呢？</p><h3 id="produce-关键逻辑抽象" tabindex="-1">Produce 关键逻辑抽象 <a class="header-anchor" href="#produce-关键逻辑抽象" aria-label="Permalink to &quot;Produce 关键逻辑抽象&quot;">​</a></h3><p>正如上文所说，使用 Immer.js，你只需要在项目里轻轻地 Import 一个名为 <code>produce</code> 的 API。</p><p>Immer.js 的一切奥秘都蕴含在 <code>produce</code> 里，包括其对 Proxy 的运用。</p><p>那么 <code>produce</code> 是如何工作的呢？</p><p>Immer.js 的源代码虽然简洁，但整个读完也是个力气活。这里我们只关注 <code>produce</code> 函数的核心逻辑，我将其提取为如下的极简版本（解析在注释里）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">recipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 预定义一个 copy 副本</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copy</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 定义 base 对象的 proxy handler</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> baseHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 先检查 copy 是否存在，如果不存在，创建 copy</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">copy) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        copy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 如果 copy 存在，修改 copy，而不是 base</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      copy[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 被 proxy 包装后的 base 记为 draft</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> draft</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(base, baseHandler)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将 draft 作为入参传入 recipe</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  recipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(draft)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 返回一个被“冻结”的 copy，如果 copy 不存在，表示没有执行写操作，返回 base 即可</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // “冻结”是为了避免意外的修改发生，进一步保证数据的纯度</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">freeze</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(copy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> base)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>接下来我尝试对这个超简易版的 producer 进行一系列的调用（解析在注释里）：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 这是我的源对象</span></span>\n<span class="line"><span>const baseObj = {</span></span>\n<span class="line"><span>  a: 1,</span></span>\n<span class="line"><span>  b: {</span></span>\n<span class="line"><span>    name: &quot;修言&quot;</span></span>\n<span class="line"><span>  }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 这是一个执行写操作的 recipe</span></span>\n<span class="line"><span>const changeA = (draft) =&gt; {</span></span>\n<span class="line"><span>  draft.a = 2</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 这是一个不执行写操作、只执行读操作的 recipe</span></span>\n<span class="line"><span>const doNothing = (draft) =&gt; {</span></span>\n<span class="line"><span>  console.log(&quot;doNothing function is called, and draft is&quot;, draft)</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 借助 produce，对源对象应用写操作，修改源对象里的 a 属性</span></span>\n<span class="line"><span>const changedObjA = produce(baseObj, changeA)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 借助 produce，对源对象应用读操作</span></span>\n<span class="line"><span>const doNothingObj = produce(baseObj, doNothing)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 顺序输出3个对象，确认写操作确实生效了</span></span>\n<span class="line"><span>console.log(baseObj)</span></span>\n<span class="line"><span>console.log(changedObjA)</span></span>\n<span class="line"><span>console.log(doNothingObj)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 【源对象】 和 【借助 produce 对源对象执行过读操作后的对象】 还是同一个对象吗？</span></span>\n<span class="line"><span>// 答案为 true</span></span>\n<span class="line"><span>console.log(baseObj === doNothingObj)</span></span>\n<span class="line"><span>// 【源对象】 和 【借助 produce 对源对象执行过写操作后的对象】 还是同一个对象吗？</span></span>\n<span class="line"><span>// 答案为 false</span></span>\n<span class="line"><span>console.log(baseObj === changedObjA)</span></span>\n<span class="line"><span>// 源对象里没有被执行写操作的 b 属性，在 produce 执行前后是否会发生变化？</span></span>\n<span class="line"><span>// 输出为 true，说明不会发生变化</span></span>\n<span class="line"><span>console.log(baseObj.b === changedObjA.b)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>下图为上述代码的执行结果 <code>console</code> ：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073c4ef3b9ba404281729f6f9ac9a11e~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073c4ef3b9ba404281729f6f9ac9a11e~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>如果你想使用 <code>produce</code> 本体验证上述用例，你只需要在项目里引入 <code>produce</code> 后，注释掉我们自定义的 <code>produce</code> 即可。</p><p><code>produce</code> 本体运行该测试用例的执行结果 <code>console</code> 如下：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58f9d44038184527bfd6dfa5b07103ce~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58f9d44038184527bfd6dfa5b07103ce~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>两边的输出完全一致，也就是说至少对这个基础用例来说，我们的极简版 <code>produce</code> 是可以复刻 <code>produce</code> 本体的表现的。</p><p>而 Immer.js 对 Proxy 的巧思，恰恰就藏在这个极简 <code>produce</code> 里。</p><p>欲知巧思何在，且看下回分解~</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',59)]))}]]);export{p as __pageData,e as default};
