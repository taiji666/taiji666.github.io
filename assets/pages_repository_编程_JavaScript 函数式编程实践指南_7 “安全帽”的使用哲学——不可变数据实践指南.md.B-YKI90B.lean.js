import{_ as s,c as a,G as n,b as i}from"./chunks/framework.D5KJDRhN.js";const p=JSON.parse('{"title":"7 “安全帽”的使用哲学——不可变数据实践指南","description":"","frontmatter":{"title":"7 “安全帽”的使用哲学——不可变数据实践指南","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/7 “安全帽”的使用哲学——不可变数据实践指南"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/7 “安全帽”的使用哲学——不可变数据实践指南.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/7 “安全帽”的使用哲学——不可变数据实践指南.md","lastUpdated":1739887664000}');const e=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/7 “安全帽”的使用哲学——不可变数据实践指南.md"},[["render",function(s,p,e,l,t,h){return i(),a("div",null,p[0]||(p[0]=[n('<p>在上一节，我们围绕“什么是不可变数据”这个话题进行了深入的探讨，并建立了不可变数据和函数纯度之间的关联关系。我们已经明确知道，<strong>要想写出好的函数式代码，就需要确保数据的不可变性。</strong></p><p>理解了“what”和“why”的问题，本节我们来好好聊一下“how”。</p><h2 id="不可变-不是要消灭变化-而是要控制变化" tabindex="-1">“不可变”不是要消灭变化，而是要控制变化 <a class="header-anchor" href="#不可变-不是要消灭变化-而是要控制变化" aria-label="Permalink to &quot;“不可变”不是要消灭变化，而是要控制变化&quot;">​</a></h2><p>大家知道，我们现代前端应用的复杂度整体是比较高的，其中最引人注目的莫过于“状态的复杂度”。</p><p>“状态”其实就是数据。</p><p>一个看似简单的 H5 营销游戏页面，背后可能就有几十上百个状态需要维护，如果没有状态之间的相互作用、相互转化，又怎能将精彩纷呈的前端交互呈现给用户呢？</p><p>程序失去变化，宛如人类失去灵魂。</p><p>所以咱们说，消灭变化是不可能的事情，也是万万不可的事情。</p><p>我们真正要做的，是<strong>控制变化，确保所有的变化都在可预期的范围内发生</strong>，从而防止我们的程序被变化“偷袭”。</p><p>正如老话所说：不怕他来，就怕他乱来。</p><p>我们本节要学习的，正是“不让他有机会乱来”的技术。</p><h2 id="名不副实的-constant" tabindex="-1">名不副实的 &quot;constant&quot; <a class="header-anchor" href="#名不副实的-constant" aria-label="Permalink to &quot;名不副实的 &quot;constant&quot;&quot;">​</a></h2><p>首先，你需要小心 constant。</p><p>我至今仍然记得，“const” 关键字首次被引入 JavaScript 的那一年，函数式编程社区的 JS 开发者几乎集体高潮——不少人都认为，const 是对 JS 语言特性的一次重大改进，它将从根本上限制开发者的reassign（重新赋值）操作，进而保障数据的不可变性。</p><p>然而，理想很丰满，现实很骨感。const 真的能够保证数据的不变性吗？我只能说，const 了，但没完全 const（此处应有苦笑）。</p><p>众所周知，const 其实是单词“constant”的缩写，而“constant”意为“不变的”。如果我说，“the price is constant”，那么我想表达的就是“价格是不变的”：我早上去买是10块钱一斤，晚上去买也应该是10块钱一斤。</p><p>也就是说，假如我们单纯从<strong>语义上</strong>来理解“const”这个关键字，那么它确实应该为我们保障数据的不变性。</p><p>但语义归语义，现实情况是，<strong>const 只能够保证值类型数据的不变性，却不能够保证引用类型数据的不变性。</strong></p><p>对于值类型来说，我这里用 <code>const</code> 创建一个变量 <code>price</code>，并将它赋值为一个值类型（Number）数据：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> price</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果我想修改 <code>price</code> 的值，我只能尝试对它进行 reassign（重新赋值），比如这样：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">price </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>显然，如下图所示，这是行不通的，毕竟我们的 <code>const</code> 生下来就是专门阻止你做 reassign 这个动作的。</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a98fab8e8c1431b82c1cf30194d7d19~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a98fab8e8c1431b82c1cf30194d7d19~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>只要禁止了 reassign， 就堵死了修改值类型变量的唯一一条路，也就确保了其数据内容的不变性。</p><p>因此，对于存储值类型数据的变量来说，<code>const</code> 确实能够确保其内容的不变性。</p><p>但对于引用类型来说，就算堵住了 reassign，也不影响我们修改数据的内容。 比如这段代码就是不会抛错的：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> me</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这一行不会报错</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">me.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 35</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(me)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在这个案例中，我同样是使用 <code>const</code> 关键字创建了变量 <code>me</code>，但在尝试修改 me 的内容时，我并没有将一个新的对象 reassign 给 me 变量，而是使用“.age”语法来访问并修改既有对象的其中一个属性。</p><p><code>const</code> 没想到啊，引用类型的数据内容改变居然根本不需要 reassign。没有了 reassign，<code>const</code> 察觉不到变化的发生，也就只能原地摆烂了。</p><p>因此，<strong><code>const</code> 对数据不变性的保证是有前提的，对于引用类型来说，const 并没有什么卵用</strong>。</p><p>事实上，由于值类型数据天然存在不可变性，当我们讨论“JS 数据不可变性”时，更多的其实就是在讨论如何保证【引用类型】数据的不可变性。</p><h2 id="不可变数据の实践原则-拷贝-而不是修改" tabindex="-1">不可变数据の实践原则：拷贝，而不是修改 <a class="header-anchor" href="#不可变数据の实践原则-拷贝-而不是修改" aria-label="Permalink to &quot;不可变数据の实践原则：拷贝，而不是修改&quot;">​</a></h2><p>既然 constant 指望不上，那么我们有什么办法来确保引用类型数据的不可变性呢？</p><p>答案也很简单，大家只需要记住一个原则：<strong>不要修改，要拷贝。</strong></p><h3 id="拷贝行为实践-安全、快速、药到病除" tabindex="-1">拷贝行为实践：安全、快速、药到病除 <a class="header-anchor" href="#拷贝行为实践-安全、快速、药到病除" aria-label="Permalink to &quot;拷贝行为实践：安全、快速、药到病除&quot;">​</a></h3><p>这里我们继续沿用上一节招聘平台的例子，首先我有一个编号为001的岗位，它的主要信息囊括在这样一个对象里：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JOB_INFO_001</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {level: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, workTime:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , type:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;engineer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, city:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;New York&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>某天，hr找到我说，想要给代码里添加这样一段动态增加新职位的逻辑：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  首先确认公司当前的高管职位总数是否少于一定的阈值，从而决定要增加的新职位是高管职位还是基础职位 (这里我们假定有一个现成的函数可以使用，它叫做 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`isHighPosition()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">）</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  如果 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`isHighPosition()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 调用返回为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`true`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，那么就动态地增加一个高管职位，这个职位基本所有信息都和某个现有的基础职位（此处以</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`001`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">为例）一致，只有 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`level`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 需要调整为 10。</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  否则，不增加高管职位，只增加一个基础职位（此处以</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`001`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">为例）。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个需求很简单，我们先来无脑实现一个粗糙版本：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 hr 的需求实现为函数 dynamicCreateJob()</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dynamicCreateJob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">baseJob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newJob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseJob</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 判断当前是否需要增加一个高管职位</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isHighPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 针对高管职位，调整level信息</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      newJob.level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newJob</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里以 001 为例，对函数进行测试</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dynamicJob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dynamicCreateJob</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JOB_INFO_001</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这个粗糙版本显然并没有遵循“不可变数据”的原则——它直接在 <code>baseJob</code> 的对象本体上进行了篡改，这将导致 <code>JOB_INFO_001</code> 的内容直接被覆盖，从而影响整个程序中所有引用到 <code>JOB_INFO_001</code> 的逻辑模块，导致这些模块集体“躺枪”。</p><p>人生建议：<strong>不要修改 baseJob，而是修改它的副本</strong>：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 将 hr 的需求实现为函数 dynamicCreateJob()</span></span>\n<span class="line"><span>function dynamicCreateJob(baseJob) {</span></span>\n<span class="line"><span>  // 创建一个 baseJob 的副本</span></span>\n<span class="line"><span>  let newJob = {...baseJob}</span></span>\n<span class="line"><span>  // 判断当前是否需要增加一个高管职位</span></span>\n<span class="line"><span>  if(isHighPosition()) {</span></span>\n<span class="line"><span>      // 针对高管职位，调整level信息</span></span>\n<span class="line"><span>      newJob.level = 10 </span></span>\n<span class="line"><span>  }</span></span>\n<span class="line"><span>  return newJob</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 这里以 001 为例，对函数进行测试</span></span>\n<span class="line"><span>const dynamicJob = dynamicCreateJob(JOB_INFO_001)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这样一来，baseJob 和 newJob 就彻底变成了两个泾渭分明的对象了。我对 newJob 所做的任何修改，都不会影响到 baseJob。</p><p>通过拷贝，我们顺利地<strong>将变化控制在了 <code>dynamicCreateJob()</code> 函数内部</strong>，避免了对全局其它逻辑模块的影响。</p><h3 id="拷贝的目的-确保外部数据的只读性" tabindex="-1">拷贝的目的：确保外部数据的只读性 <a class="header-anchor" href="#拷贝的目的-确保外部数据的只读性" aria-label="Permalink to &quot;拷贝的目的：确保外部数据的只读性&quot;">​</a></h3><p>用拷贝代替修改后，<code>baseJob</code> 对于 <code>dynamicCreateJob()</code> 函数来说，成为了一个彻头彻尾的<strong>只读数据</strong>。</p><p>关于只读数据，如果你是一个函数式编程发烧友，你可能会在一些文章中读到过一种过度概括的观点：不可变数据的内涵就是创造并使用“只读数据”。</p><p>之所以说这种观点是过度概括的，是因为它少了一个“<strong>外部数据</strong>”的限定词。</p><p>正如我在开篇时强调的那样，如果一个程序里只有只读数据、而没有数据的变化，这个程序几乎无法做任何事情。</p><p>因此，无论是什么样的编程范式，<strong>只读数据都必须和可写数据共存</strong>。</p><p>对于函数式编程来说，<strong>函数的外部数据是只读的，函数的内部数据则是可写的</strong>。</p><p>对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些<strong>外部数据</strong>，存在【只读】的必要。</p><blockquote><p>注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。</p></blockquote><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本节，我们探讨了不可变数据的两种最直接的实践思路：对于值类型数据，我们可以使用 const 来确保其不变性；对于引用类型数据，我们可以使用拷贝来确保源数据的不变性。</p><p>这其中，引用类型数据的不可变性值得我们再三思考——拷贝是否是一个完美的解法？它背后是否隐藏着种种问题？有没有比拷贝更加高效的解法呢？</p><p>答案当然是有啦，下一节，我们就将讨论不可变数据的进阶解法中最有名的一个——Persistent Data Structure（持久化数据结构）。</p><h2 id="补充" tabindex="-1">补充 <a class="header-anchor" href="#补充" aria-label="Permalink to &quot;补充&quot;">​</a></h2><p>在本节，我们探讨了拷贝行为在函数式编程中的作用与意义，由此不难联想到另一个更加独立的命题：如何在 JS 中实现引用类型数据的拷贝？</p><p>这也是一道非常经典、也相对基础的面试题。</p><p>由于过于经典，相关的探讨在社区随处可见，有过面试经历的同学也基本都能对此信手拈来。这里我并不打算单独为其铺陈一个章节来叙述。</p><p>但对于不熟悉拷贝的同学，我想要给你以下的学习建议：</p><p>在本文的示例中，我使用了扩展运算符来拷贝一个简单的对象。</p><p>类似的，你也可以使用 Object.assign 接口来实现拷贝。</p><p>而对于数组，除了扩展运算符外，还有像 slice、concat、map 等实用的数组接口供你挑选。</p><p>当然啦，这还并非“拷贝”的全貌，若想学得精些，你还需要辨析深、浅拷贝的区别。</p><p>其中深拷贝的实现尤其耐人寻味，也经常作为大厂的笔试题出现。</p><p>学习深拷贝时，我建议你不仅要多吸收社区群众的智慧，更要善于向成熟的工具方法库进行学习，<a href="https://github.com/lodash/lodash" target="_blank" rel="noreferrer">lodash</a> 的 deepClone 函数就是一个不错的教材。</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',72)]))}]]);export{p as __pageData,e as default};
