import{_ as s,c as a,G as i,b as n}from"./chunks/framework.D5KJDRhN.js";const p=JSON.parse('{"title":"5 “一等公民”的故事——聊聊 First-Class Function","description":"","frontmatter":{"title":"5 “一等公民”的故事——聊聊 First-Class Function","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/5 “一等公民”的故事——聊聊 First-Class Function"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/5 “一等公民”的故事——聊聊 First-Class Function.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/5 “一等公民”的故事——聊聊 First-Class Function.md","lastUpdated":1740213738000}');const l=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/5 “一等公民”的故事——聊聊 First-Class Function.md"},[["render",function(s,p,l,e,t,h){return n(),a("div",null,p[0]||(p[0]=[i('<p>本节，我们来认识函数式编程的第二个关键特征：<strong>函数是一等公民</strong></p><h2 id="头等函数-与-一等公民" tabindex="-1">“头等函数”与“一等公民” <a class="header-anchor" href="#头等函数-与-一等公民" aria-label="Permalink to &quot;“头等函数”与“一等公民”&quot;">​</a></h2><p>开篇我想先对两个常见的概念进行辨析：“头等函数”与“一等公民”。</p><p>有的同学比起“函数是一等公民”，会更加熟悉“xx拥有头等函数”这样的说法。其实两者表达的是同个意思。</p><p>如果你在维基百科中搜索“头等函数”这一词条，你将找到这样一条描述：</p><blockquote><p>a programming language is said to have <strong>first-class functions</strong> if it treats functions as first-class citizens.</p></blockquote><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> （笔者译：如果一门编程语言将函数当做一等公民对待，那么这门语言被称作“拥有头等函数“）    </span></span>\n<span class="line"><span>                                                    ——wikipedia</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这条定义将“头等函数”与“函数是一等公民”划上了等号——“头等函数”就是“被当做一等公民对待的函数”。</p><p>那么什么是程序世界的“一等公民”？“一等公民”又有哪些“特殊待遇”呢？</p><p>我们或许可以从 MDN 对“First-Class Function”的阐释中找到这个问题的答案：</p><blockquote><p>当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有<strong>头等函数</strong>。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。 ——MDN Web Docs</p></blockquote><p>【划重点】：头等函数的核心特征是“<strong>可以被当做变量一样用</strong>”。</p><p>“可以被当做变量一样用”意味着什么？它意味着：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  可以被当作参数传递给其他函数</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  可以作为另一个函数的返回值</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  可以被赋值给一个变量</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>以上三条，就是“函数是一等公民”这句话的内涵。</p><h2 id="一等公民-的-js-函数" tabindex="-1">“一等公民”的 JS 函数 <a class="header-anchor" href="#一等公民-的-js-函数" aria-label="Permalink to &quot;“一等公民”的 JS 函数&quot;">​</a></h2><p>接下来我们首先趁热打铁，通过几个例子来验证一下“一等公民”的特征是如何在 JS 函数身上得到体现的。</p><h3 id="js-函数可以被赋值给一个变量" tabindex="-1">JS 函数可以被赋值给一个变量 <a class="header-anchor" href="#js-函数可以被赋值给一个变量" aria-label="Permalink to &quot;JS 函数可以被赋值给一个变量&quot;">​</a></h3><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将一个匿名函数赋值给变量 callMe</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callMe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello World！&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 callMe 的内容</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callMe)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 callMe</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callMe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将一个新的匿名函数赋值给变量 callMe</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callMe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello 修言~&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 callMe 的内容</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callMe)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 callMe</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callMe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在这个例子中，我们成功将两个匿名函数先后赋值给了变量 <code>callMe</code>。<code>callMe</code> 被赋值为一个函数后，我们不仅可以通过添加两个圆括号来调用它，也可以像访问普通变量一样查看它的内容。</p><h3 id="js-函数可以作为参数传递" tabindex="-1">JS 函数可以作为参数传递 <a class="header-anchor" href="#js-函数可以作为参数传递" aria-label="Permalink to &quot;JS 函数可以作为参数传递&quot;">​</a></h3><p>咱要是说“JS 函数作为参数传递”，你可能还不太能转过这个弯儿来。但咱要是说“回调函数”，你肯定一下就来精神了——它可不就是在说回调函数么！</p><p>众所周知，回调函数是 JS 异步编程的基础。在前端，我们常用的事件监听、发布订阅等操作都需要借助回调函数来实现。比如这样：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consoleTrigger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;spEvent 被触发&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}   </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jQuery.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;spEvent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, consoleTrigger)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在这个例子中，<code>consoleTrigger</code> 函数就作为 <code>subscribe</code> 函数的第 2 个入参被传递。</p><p>而在 Node 层，我们更是需要回调函数来帮我们完成与外部世界的一系列交互（也就是所谓的“副作用”）。</p><p>这里举一个异步读取文件的例子：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 输出文件内容</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -- 异步读取文件</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, showData)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中， <code>showData</code> 函数作为 <code>readFile</code> 函数的第 3 个入参被传递。</p><h3 id="js-函数可以作为另一个函数的返回值" tabindex="-1">JS 函数可以作为另一个函数的返回值 <a class="header-anchor" href="#js-函数可以作为另一个函数的返回值" aria-label="Permalink to &quot;JS 函数可以作为另一个函数的返回值&quot;">​</a></h3><p>函数作为返回值传递，基本上都是馋人家闭包的特性。比如下面这个例子：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> baseAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> addWithOne</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> baseAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// .... (也许在许多行业务逻辑执行完毕后）</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addWithOne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>显然，<code>add</code> 函数想要做一个加法，但是在只能够确认其中一个加数（<code>a</code>）的时候，它并不急于立刻做这个加法。</p><p>怎么办呢？先把这个已经确定的加数（<code>a</code>）以【闭包中的自由变量】的形式存起来，然后返回一个待执行的加法函数。等什么时候第二个加数也确定了，就可以立刻执行这段逻辑。</p><h2 id="一等公民-的本质-js-函数是可执行的对象" tabindex="-1">“一等公民”的本质：JS 函数是可执行的对象 <a class="header-anchor" href="#一等公民-的本质-js-函数是可执行的对象" aria-label="Permalink to &quot;“一等公民”的本质：JS 函数是可执行的对象&quot;">​</a></h2><p>吃了这么多栗子🌰，想必大家现在已经深刻地理解了“函数是 JavaScript 的一等公民”这句话的内涵。</p><p>那么为什么 JS 中的函数这么牛x，可以为所欲为呢？</p><p>本质上是因为<strong>它不仅仅是个函数，它还是个对象</strong>。</p><p>如下图所示，JS 函数确实是一个对象，它的类型是 Function，它具备 Function 原型上的一切属性和方法：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a749b992a86847c89df2c2718e997e7c~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a749b992a86847c89df2c2718e997e7c~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37fbeac64cbd48258dee60e9a0d2590e~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37fbeac64cbd48258dee60e9a0d2590e~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>这里需要强调的是，根据最新版的红宝书（《JavaScript 高级程序设计》第4版）定义，JavaScript 有且仅有以下 7 种数据类型：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Undefined 类型</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Null 类型</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Boolean 类型</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Number 类型</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   String 类型</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Symbol 类型</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Object 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>（作者注：结合最新的 ES 标准，还有一个新的类型 BigInt）</p><p>尽管在早期 ES 规范还不太清晰的时候，有一些 JS 著作中曾经将 Function 单独拿出来作为和 Object 并列的一种数据类型。但事实上，<strong>并没有一种数据类型叫 Function</strong>，Function 和 Array、Date 这些 built-in Class 一样，都属于对象类型。</p><p>既然函数也是对象，那么对象能干的事，函数也能干。</p><p>对象能干啥？别的不说，咱对照“一等公民”的特征来一个一个看一下：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  能不能赋值给变量？能！</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  能不能作为函数参数传递？能！</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  能不能作为返回值返回？能！</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>到这里我们不难看出，&quot;First-Class Function（头等函数）&quot; 的本质，其实是&quot;First-Class Object（头等对象）”。JS 函数的本质，就是<strong>可执行的对象</strong>。</p><h2 id="拓展-一等公民的函数-意味着什么" tabindex="-1">拓展：“一等公民的函数”意味着什么 <a class="header-anchor" href="#拓展-一等公民的函数-意味着什么" aria-label="Permalink to &quot;拓展：“一等公民的函数”意味着什么&quot;">​</a></h2><h3 id="一等公民-的学术背景" tabindex="-1">“一等公民”的学术背景 <a class="header-anchor" href="#一等公民-的学术背景" aria-label="Permalink to &quot;“一等公民”的学术背景&quot;">​</a></h3><p>&quot;一等公民“这一词条最早可以追溯到 1960 年，彼时计算机科学家<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%C2%B7%E6%96%AF%E7%89%B9%E9%9B%B7%E5%A5%87" target="_blank" rel="noreferrer">克里斯托弗·斯特雷奇</a>仅仅是引入了这一概念，但并没有给出严格的术语定义，只是给出了<a href="https://zh.wikipedia.org/wiki/ALGOL" target="_blank" rel="noreferrer">ALGOL</a>语言中实数和过程的对比。</p><p>时下当我们谈及“一等公民”的时候，更多的是在讨论 <a href="https://zh.wikipedia.org/w/index.php?title=%E6%8B%89%E6%96%90%E5%B0%94%C2%B7%E8%8A%AC%E5%85%8B%E5%B0%94&amp;action=edit&amp;redlink=1" target="_blank" rel="noreferrer">拉斐尔·芬克尔</a> 在 《<em>Advanced Programming language Design</em>》一书中所描述的”一等值“：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbdbb6f7cfc642dbbc9b91eb580eee01~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbdbb6f7cfc642dbbc9b91eb580eee01~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>如图中的表格所示，老爷子根据以下三个条件的满足情况，将值划分为了三种类型：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pass value as a parameter (能否当做参数传递）</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return value from a procedure（能否作为返回值返回）</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  assign value into a variable（能否赋值给变量）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>按照表格的示意，三个条件全部满足的，就认为它是“一等值”，也就是“一等公民”。只满足第一条的，则是“二等值”，一条也不满足的，属于”三等值”。</p><p>事实上，除了“一等值”的定义被广泛使用至今外，“二等值”、“三等值”这些定义在行业里的接受度并不高。大家知道有这种说法即可。</p><h3 id="一等公民-的现实意义" tabindex="-1">“一等公民”的现实意义 <a class="header-anchor" href="#一等公民-的现实意义" aria-label="Permalink to &quot;“一等公民”的现实意义&quot;">​</a></h3><p>“一等公民的函数”，并不仅仅意味着函数符合了这样那样的特征，还意味着函数在 JS 世界中，具有最高的自由度。</p><p>这“最高的自由度”，是从能力的角度来说的。它意味着函数是 JS 世界里技能树最满的家伙，别人能干的活，它能干，别人干不了的活，它还能干。</p><p>这直接决定了函数可以在 JS 世界里横着走，可以帮我们做任何我们想要做的事情，这也使“以函数为基本单位构建应用程序”成为可能。</p><p>由此我们可以断言，任何语言如果想要实现对函数式编程范式的支持，就必须支持“函数是一等公民”这一特性。</p>',63)]))}]]);export{p as __pageData,l as default};
