import{_ as s,c as i,G as a,b as n}from"./chunks/framework.D5KJDRhN.js";const p=JSON.parse('{"title":"17 范畴论启发下的函数设计模式——一个数据盒子的故事","description":"","frontmatter":{"title":"17 范畴论启发下的函数设计模式——一个数据盒子的故事","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/17 范畴论启发下的函数设计模式——一个数据盒子的故事"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/17 范畴论启发下的函数设计模式——一个数据盒子的故事.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/17 范畴论启发下的函数设计模式——一个数据盒子的故事.md","lastUpdated":1740213738000}');const e=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/17 范畴论启发下的函数设计模式——一个数据盒子的故事.md"},[["render",function(s,p,e,t,l,h){return n(),i("div",null,p[0]||(p[0]=[a('<p>在小册<a href="https://juejin.cn/book/7173591403639865377/section/7175420951075504188" target="_blank" rel="noreferrer">第4节</a>我们说过，函数式编程是一门有着深刻数学背景的学问，这其中一个最为关键的背景就是<strong>范畴论</strong>。</p><p>Functor、Monad、SemiGroup、Monoid 这些看上去非常唬人的函数式编程概念，全部源于范畴论。</p><p>本节作为一个过渡章节，旨在帮助大家完成以下三个目标：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  铺陈【必要的】数学背景知识和学习方法，理解后续章节中各种奇葩名词的来路，并渐渐习惯它们的存在</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  明确范畴论在函数式编程中的应用场景：没有别的，就是</span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**函数组合**</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  通过认识 Functor（函子）的基本形态，建立“数据盒子”的思维模型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="方法论-范畴论编程的摸鱼学习心法" tabindex="-1">方法论：范畴论编程的<s>摸鱼</s>学习心法 <a class="header-anchor" href="#方法论-范畴论编程的摸鱼学习心法" aria-label="Permalink to &quot;方法论：范畴论编程的~~摸鱼~~学习心法&quot;">​</a></h2><p>函数这个概念我们从小学就开始接触，但范畴论却是一门大学里某些特定专业才会开的课。</p><p><strong>这个数学理论虽然很复杂，但它对应写出来的代码却很简单。</strong></p><p>虽然我们不算是专业的数学人才，但我们是专业的程序员呀！</p><p>数学符号我看不懂，JS 代码我还看不懂吗？</p><p>本着“以己之长学人之长”的原则，我建议大家在学习范畴论相关的函数设计模式时，不必太拘泥于“由数学去推导数学”这个过程，而应该试着“<strong>用代码去推导数学</strong>”。</p><p><strong>厨师在做菜的过程中，自然会通过现象去理解食物分子的变化。</strong></p><p><strong>而我们在编码的过程中，自然也能够通过代码的行为来理解范畴论的内核。</strong></p><p>理解了相应的代码，也就理解了【你写函数式代码所需要知道的那部分】范畴论。</p><h2 id="组合问题的链式解法-一个盒子的故事" tabindex="-1">组合问题的链式解法：一个盒子的故事 <a class="header-anchor" href="#组合问题的链式解法-一个盒子的故事" aria-label="Permalink to &quot;组合问题的链式解法：一个盒子的故事&quot;">​</a></h2><p><strong>从编码的角度看，范畴论在 JS 中的应用，本质上还是为了解决函数组合的问题。</strong></p><p>我们看回 Composition 小节案例中的这几个待组合的函数：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> multiply3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> divide2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果不借助 compose/pipe 函数，我们还有其它的思路构造声明式的数据流吗？</p><p><strong>范畴论告诉我们，有的，那就是构造一个【能够创造新盒子】盒子。</strong></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Box</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)),</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Box 函数的关键在于 map 方法，这个方法被调用时会做两件事情：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  执行传入的回调函数 f ，入参为当前 Box 的参数 x</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  将 f(x) 的计算结果放进一个新的 Box 里</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里我以 add4 为例，尝试把它作为 Box.map 的入参传入：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newBox</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(add4)  </span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 14</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看出，map 执行结束后，newBox 的函数上下文中，已经保存了新的 x 的值，x = 14。</p><p>newBox 也是一个 Box，它也是有 map 方法的。</p><p>而 map 方法又可以把新的计算结果传递给下一个 Box。</p><p>通过反复地创造 Box、反复调用 Box 上的 map 方法，我们就能得到一个声明式的函数调用链：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 值为 21</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> computeBox</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(add4)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(multiply3)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(divide2)  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在这个调用链中，我们只需要关注每一次 map 调用的入参函数 f，即可得知每一步在执行什么任务。</p><p>至于每一步的计算中间态是如何在不同的函数之前流转的、map 又是如何构造新的 Box 的，这些执行细节统统都被 Box 消化掉了。</p><p><strong>这个盒子，其实就是范畴论在函数式编程中的一种表达。</strong></p><h2 id="复合运算-范畴论在编程中最核心的应用" tabindex="-1">复合运算：范畴论在编程中最核心的应用 <a class="header-anchor" href="#复合运算-范畴论在编程中最核心的应用" aria-label="Permalink to &quot;复合运算：范畴论在编程中最核心的应用&quot;">​</a></h2><p>什么是范畴？</p><blockquote><p>A category consists of objects and arrows that go between them.<br> 修言直译：一个范畴由一些对象以及这些对象之间的箭头组成。<br> ——《Category Theory For Programmers》</p></blockquote><p>我们可以用下图来示意一个范畴：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738e5974e6b14465bb9d4e24e7d038e6~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738e5974e6b14465bb9d4e24e7d038e6~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>图中的圆圈表示“对象”，这里的“对象”是一个数学术语，我们可以简单地把它理解为程序中的“数据”。</p><p>而箭头描述的是对象与对象之间的映射，在范畴论中，它的名字叫“态射”。“态射”，其实就是函数。</p><p>也就是说，从程序的视角出发，范畴包括了以下两个要素：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  一组</span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**数据**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的集合（所谓“对象”）</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  一些操作该数据集合的</span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**函数**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">（所谓“态射”）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>它们恰恰也都是函数式编程理论中的基础要素。</p><p>而范畴中的函数（也即“态射”），是可以进行<strong>复合运算</strong>的。</p><p>假设 f、g 均为一个范畴下的函数，它们之间的复合运算就可以表示为：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>g(x) · f(x)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>用 JS 代码表示为：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, f)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>注意，在数学的“复合”中，函数的书写顺序和执行顺序是相反的，<code>g · f</code> 表示先执行 <code>f</code> 再执行 <code>g</code>。</p><p>在我们前面学过的组合工具函数中， compose 函数遵循的正是这个数学复合顺序，而 pipe 函数遵循的是计算机的逻辑顺序。</p><p>此外，多个函数的复合，还必须要满足一条原则，叫做“结合律”。</p><p>这里我用代码来表示“结合律”：假设 f、g、h 均为一个范畴下的函数，它们之间应该具备这样的关系特征：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, g), h) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, h))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>复合运算与结合律，恰恰完整地描述了我们刚学过去不久的“函数组合”思想。</strong></p><p>不仅如此，我甚至还在<a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" target="_blank" rel="noreferrer">一本范畴论专著</a>中读到过这样一句话：</p><blockquote><p><strong>the essence of a category is composition</strong><br> 修言直译：<strong>范畴论的本质就是复合</strong></p></blockquote><p>作为一个数学造诣不算很深的程序员，范畴论的本质到底是不是复合，咱也不知道，咱也不敢问，咱也不好下定论。</p><p>但是作为一个死磕过函数式编程、并且在大型项目中反复实践过函数式编程的老开发，我可以非常确信地说，<strong>范畴论对于函数式编程最关键的影响，就在于“复合”，或者说在于“函数的组合”</strong>。</p><p>因此，绕过范畴论来谈函数式编程，是不恰当的。</p><p>尽管形如 Functor、Monad、Semigroup 和 Monoid 这样的“怪名字”，看上去确实有些劝退。但只要我们能把握住【复合】这一本质，恰当地从工程的视角建立起数学名词与函数逻辑之间的关系，再奇葩的名词也不过是我们信手拈来的编码工具而已。</p><p>到这里，铺垫结束，我们回到正文里来，继续讲讲 Box 的故事。</p><p>这个 Box，在范畴论中有一个学名，叫做“Functor（函子）”。</p><p>从数学定义的角度来说， Functor（函子） 是一种能够将一个范畴映射到另一个范畴的东西。</p><p>这个定义到底在说啥大家倒也不用纠结_(:з」∠)_，重要的是，从写代码的角度来看，我们如何认识 Functor 呢？</p><h2 id="此盒又名-functor-函子" tabindex="-1">此盒又名 Functor（函子） <a class="header-anchor" href="#此盒又名-functor-函子" aria-label="Permalink to &quot;此盒又名 Functor（函子）&quot;">​</a></h2><p>到这里，我们就迎来了本节第二重要的问题：Functor 是什么？</p><p>对范畴论实践最为深入的 Haskell 语言告诉我们：</p><blockquote><p><strong>A functor is something that can be mapped over.</strong><br> 修言直译：一个 Functor 就是一个能够被映射的“东西”。</p></blockquote><p>这句话里有两个关键字：“<strong>东西</strong>” 和 “<strong>映射</strong>”。</p><p>在 JS 中，这个“<strong>东西</strong>”可以被看作一个盒子、一个容器，它本质上是一种数据结构，一种“类型”。</p><p>而“<strong>映射</strong>”借助的就是 map 方法了。</p><p>也就是说，<strong>Functor 指的是一个实现了 map 方法的数据结构</strong>。</p><p>那么问题来了：</p><p><strong>这个 Functor 到底能干啥？难道它只是 compose 的另一种姿势而已吗？</strong></p><p><strong>实现了 map 的盒子叫 Functor，那有没有实现了其它方法的盒子呢？这些盒子又叫啥、又有啥用呢？</strong></p><p>这些问题都非常关键，但是现在，我们还有一个更关键的事情要去讨论，那就是“盒子”本身。</p><h2 id="盒子模式下的代码组织方式" tabindex="-1">盒子模式下的代码组织方式 <a class="header-anchor" href="#盒子模式下的代码组织方式" aria-label="Permalink to &quot;盒子模式下的代码组织方式&quot;">​</a></h2><p>Functor、Monad、Semigroup、Monoid......这些由范畴论推导出来的编码模式，我们可以记为“范畴论设计模式”。</p><p>在修言的感性认知里，更习惯于把它们看作是“盒子模式”。</p><p>因为这些概念的编码表达是非常相近的，它们彼此之间的差异主要在接口实现上。</p><p>但纵使你把接口玩出花来，盒子就是盒子，盒子之间必定是有一些共性的。</p><p>在深入分析具体的盒子之前，我们不妨先从整体上拿捏一下【盒子的共性】。</p><p><strong>盒子的实现有哪些规律？</strong></p><p>首先，<strong>盒子是一个存放数据的容器</strong>，它的内部肯定会维护一套数据。</p><p>这套数据总是以盒子入参的形式传入，总是作为我们整个组合链的起点。</p><p>同时，<strong>盒子内部可以定义一系列操作数据的函数</strong>。</p><p>这些函数未必需要具备【<strong>创建并返回新的盒子</strong>】的能力，但是<strong>关键的函数、决定盒子性质的那些函数</strong>，往往需要具备这个能力。</p><p>以 Functor 为例，决定一个盒子能否成为 Functor 的是 map 函数，map 就是 Functor 的“关键函数”，map 必须具有【<strong>创建并返回新的盒子</strong>】的能力（如下图）。</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb7dc618cccf49b098ea5b2df36fc98b~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb7dc618cccf49b098ea5b2df36fc98b~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p><strong>盒子的本质是什么？</strong></p><p>盒子的本质是一套<strong>行为框架</strong>。</p><p>对于盒子来说，其内部容纳的数据是动态的，而数据的<strong>行为模式</strong>是预定义的。</p><p>以本文的 Box 为例，Box 函数会创建一个容器，对这个容器来说，入参 x 是未知的，但是针对 x 可以执行 map 行为是确定的。</p><p>正是这个“map 行为” ，决定了 Box 容器是一个 Functor。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>以上描述的“规律”和“本质”，适用于我们本册即将探讨的所有“盒子”。</p><p>只要能够理解这两个要点，后面几节的内容对你来说就跟喝水一样简单。</p><p>接下来，我们就带着这套“盒子理论”，从 Functor 开始深入，细细去看盒子里到底能长出什么好东西来。</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',98)]))}]]);export{p as __pageData,e as default};
