import{_ as s,c as i,G as a,b as n}from"./chunks/framework.D5KJDRhN.js";const p=JSON.parse('{"title":"3 函数式编程基本功：吃透“纯函数”与“副作用”","description":"","frontmatter":{"title":"3 函数式编程基本功：吃透“纯函数”与“副作用”","date":"2025-02-22T00:00:00.000Z","categories":["JavaScript 函数式编程实践指南"],"head":[["link",{"rel":"canonical","href":"https://www.doit.ip-ddns.com/pages/repository/编程/JavaScript 函数式编程实践指南/3 函数式编程基本功：吃透“纯函数”与“副作用”"}]]},"headers":[],"relativePath":"pages/repository/编程/JavaScript 函数式编程实践指南/3 函数式编程基本功：吃透“纯函数”与“副作用”.md","filePath":"pages/repository/编程/JavaScript 函数式编程实践指南/3 函数式编程基本功：吃透“纯函数”与“副作用”.md","lastUpdated":1740213738000}');const e=s({name:"pages/repository/编程/JavaScript 函数式编程实践指南/3 函数式编程基本功：吃透“纯函数”与“副作用”.md"},[["render",function(s,p,e,l,t,h){return n(),i("div",null,p[0]||(p[0]=[a('<p>也许你曾经在 Redux 的官方文档中，读到过这样的描述：“reducer 必须是一个<strong>纯函数</strong>”。</p><p>也许你曾经在某一次面试中，遇到过这样的问题：“如何理解<strong>纯函数</strong>的优势”？</p><p>也许你曾经在某篇社区热门文章中，读到过这样的描述：“xxx 会引入<strong>副作用</strong>，这样做不够优雅”。</p><p>随着函数式编程思想在前端领域逐渐崭露头角，纯函数这个概念也越来越多地受到前端社区的关注。</p><p>在过去，它对你来说可能是一套 Redux 的编写规则，也可能是一道稍显晦涩的问答题。</p><p>但现在，你需要知道，<strong>纯函数是函数式编程的一个最大的前提，也是这坨知识体系的根基</strong>。</p><p>为了打好这个根基，我们将在接下来的两节课里深入探讨如下问题：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   纯函数、副作用的内涵</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   纯函数/非纯函数的辨析</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   从数据流的角度理解“纯”与“不纯”的本质</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   纯函数解决了什么问题</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面罗列的几个问题，足以帮助你对这块知识构建起全面的理解，也基本覆盖了面试中所有可能的提问角度。</p><p>大家不妨把这几个问题先记下来，作为自己构建知识体系的线索，也作为后续检验自己学习成果的标准。</p><p>在本节的开始，我们首先要来探讨“<strong>是什么</strong>”的问题。</p><h2 id="厘清两个概念" tabindex="-1">厘清两个概念 <a class="header-anchor" href="#厘清两个概念" aria-label="Permalink to &quot;厘清两个概念&quot;">​</a></h2><h3 id="什么是纯函数" tabindex="-1">什么是纯函数？ <a class="header-anchor" href="#什么是纯函数" aria-label="Permalink to &quot;什么是纯函数？&quot;">​</a></h3><p>同时满足以下两个特征的函数，我们就认为是纯函数：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   对于相同的输入，总是会得到相同的输出</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   在执行过程中没有语义上可观察的副作用。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="什么是副作用" tabindex="-1">什么是副作用？ <a class="header-anchor" href="#什么是副作用" aria-label="Permalink to &quot;什么是副作用？&quot;">​</a></h3><p>我们看到，在纯函数的定义中，出现了对”副作用“的描述。</p><p>相比于“函数副作用”来说，更为大家所熟知的一个概念或许是“药物副作用”：我们为了治疗A疾病服用某种药物，药物在缓解A疾病的症状之余，可能会导致B疾病。那么“引发B疾病”就是这个药物的副作用。</p><p>生活经验告诉我们， 药物副作用的产生是由“<strong>药物的影响面过大</strong>”导致的。</p><p>比如我们原本只是期望药物帮助我们消除呼吸系统的炎症，但这种药物的作用范围并不仅限于你的呼吸系统，它还会刺激你的肠胃、导致肠胃功能紊乱。</p><p>原本我们只希望它伸出一只手来解决呼吸系统的问题，但现在它却<strong>伸出了两只手，一只手帮你解决问题，另一只手创造更多的问题</strong>（如下图）：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42ac074d3d0344178e7b7bcdede5e2a9~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42ac074d3d0344178e7b7bcdede5e2a9~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>从图中我们可以看出，副作用指的正是药物在完成正常工作任务（作用于呼吸系统）之外，对外部环境（消化系统）所施加的影响。</p><p>我们对这句话稍作修改，便能够得到函数副作用的定义：</p><blockquote><p>在计算机科学中，<strong>函数副作用</strong>指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科</p></blockquote><p>简单地讲：对函数来说，它的正常工作任务就是【<strong>计算</strong>】，除了计算之外，它不应该搞别的。</p><p><strong>如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。</strong></p><p>干嚼理论太空洞，接下来我们就趁热打铁，借助几个具体的编码案例，一起来认识一下纯函数的真面目。</p><h2 id="举几个🌰来辨析一下" tabindex="-1">举几个🌰来辨析一下 <a class="header-anchor" href="#举几个🌰来辨析一下" aria-label="Permalink to &quot;举几个🌰来辨析一下&quot;">​</a></h2><h3 id="case-1-加法函数" tabindex="-1">Case #1：加法函数 <a class="header-anchor" href="#case-1-加法函数" aria-label="Permalink to &quot;Case #1：加法函数&quot;">​</a></h3><p>先来看一个 add 函数：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这个函数是不是纯函数？</p><p>答案是否定的，因为对于相同的输入，它无法做到相同的输出。</p><p>比如我们初次执行 add() 时，它会 return 一个 30 出来。</p><p>但如果我在全局作用域做了如下修改：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 40</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>此时再次调用 <code>add()</code>，我们得到的输出就将从 30 变为 70。</p><p>对于相同的输入，<code>add()</code>函数给到了不同的输出。这违背了纯函数的第一条规则：<strong>对于相同的输入，总是会得到相同的输出</strong>。</p><p>有同学可能产生这样的疑问：楼上好像是两次截然不同的输入啊？第一次输入了 <code>a=10,b=20</code>；第二次又改为了 <code>a=30,b=40</code>。</p><p>这里需要强调的是，“输入”指的是<strong>函数的入参</strong>。</p><p>对于 <code>add()</code> 函数来说，它的输入其实是一直都是 void。</p><p>那么我们怎么处理才能够使 add 函数变为一个纯函数呢？</p><p>方法也很简单，只需要把“数据的输入”这件事情完全交给入参来做就可以了，我们可以这样改造：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 30</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)   </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 40</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 70</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>简单的改造后，add 函数就能够充分满足纯函数的两个条件了：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  对于相同的输入，总是会得到相同的输出：对于相同的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`a`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`b`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 来说，它们的和总是相等的✅</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  在执行过程中没有语义上可观察的副作用：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`add()`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 函数除了加法计算之外没有做任何事，不会对外部世界造成额外影响✅</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="case-2-姓名处理函数" tabindex="-1">Case #2：姓名处理函数 <a class="header-anchor" href="#case-2-姓名处理函数" aria-label="Permalink to &quot;Case #2：姓名处理函数&quot;">​</a></h3><p>接下来我们来看一个姓名处理函数：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">firstName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">secondName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fullName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}·${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">secondName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`I am ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fullName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fullName</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">processName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;约瑟翰&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;庞麦郎&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个函数也是一个不纯的函数，问题出在这行 <code>console.log()</code> 上。</p><p><code>console.log() </code>会在控制台打印一行文字，这改变了浏览器的控制台，属于对外部世界的影响，也就是说 <strong>processName 函数在执行过程中产生了副作用</strong>。</p><p>要想把它改回纯函数也非常简单，只需要像这样把副作用摘出去就可以了：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">firstName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">secondName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fullName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}·${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">secondName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fullName</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">processName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;约瑟翰&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;庞麦郎&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="case-3-网络请求函数" tabindex="-1">Case #3：网络请求函数 <a class="header-anchor" href="#case-3-网络请求函数" aria-label="Permalink to &quot;Case #3：网络请求函数&quot;">​</a></h3><p>最后我们再来看一个非常经典的 Case：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response   </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>getData</code> 函数是否是一个纯函数？</p><p>答案是否定的，<strong>一个引入了网络请求的函数，从原则上来说是纯不起来的</strong>。</p><p>为什么网络请求会使函数变得不纯呢？我们以示例代码中的 get 请求为例来分析一下：</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   请求获取到的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`response`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 是动态的：需要通过网络请求获取的数据往往是动态的，</span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**对于相同的输入，服务端未必能够给到相同的输出**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   请求可能出错：既然是网络请求，那就一定要考虑失败率的问题。网络拥塞、机房起火、后端删库跑路等等问题都有可能导致请求过程中的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`Error`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，</span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**未经捕获的 </span><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">`Error`</span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;"> 本身就是一种副作用**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当请求方法为 <code>post</code>、<code>delete</code> 等具有“写”能力的类型时，网络请求将会执行对外部数据的写操作，这会使函数的“不纯”更进一步。</p><h2 id="纯-与-不纯-的本质" tabindex="-1">“纯”与“不纯”的本质 <a class="header-anchor" href="#纯-与-不纯-的本质" aria-label="Permalink to &quot;“纯”与“不纯”的本质&quot;">​</a></h2><p>通过对以上示例的分析，我们已经能够借助两大特征来快速地对函数的“纯”与“不纯”进行甄别。</p><h3 id="纯-的本质——有且仅有【显式数据流】" tabindex="-1">“纯”的本质——有且仅有【显式数据流】 <a class="header-anchor" href="#纯-的本质——有且仅有【显式数据流】" aria-label="Permalink to &quot;“纯”的本质——有且仅有【显式数据流】&quot;">​</a></h3><p>站在特征的肩膀上，我们再去理解纯函数的学术定义，就会简单得多：</p><blockquote><p>纯函数（Pure Function）——输入输出数据流全是<strong>显式</strong>（Explicit）的函数。<br> —— 维基百科</p></blockquote><p>定义中的“显式”这个概念，其实非常好理解，它约束的是数据的来源（<strong>入参</strong>）和出口（<strong>返回值</strong>）。</p><p>数据以入参形式传入，这叫【显式输入数据流】。</p><p>数据以返回值形式输出，这叫【显式输出数据流】。</p><p>定义中要求“输入输出数据流全是<strong>显式</strong>（Explicit）的”，那就是说数据只能以入参的形式进来，并且只能以返回值的形式出去。</p><p>由此，我们可以把“学术定义”翻译为如下的大白话：</p><blockquote><p>纯函数——<strong>输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数</strong>。 ——修·格拉底·鲁迅·言思妥耶夫斯基</p></blockquote><p>所以说，纯函数到底“纯”在哪里？</p><p>纯就纯在【<strong>显式数据流</strong>】！</p><p>那么，显式数据流是啥呢？</p><p>显式数据流意味着<strong>函数除了入参和返回值之外，不以任何其它形式与外界进行数据交换</strong>。</p><p>反复把这句话说三遍，然后我们带着这个结论重新分析一遍楼上的 3 个案例。</p><h3 id="不纯-的元凶——隐式数据流" tabindex="-1">“不纯”的元凶——隐式数据流 <a class="header-anchor" href="#不纯-的元凶——隐式数据流" aria-label="Permalink to &quot;“不纯”的元凶——隐式数据流&quot;">​</a></h3><p>对于 <strong>Case #1</strong> 中的加法函数来说，它的不纯是由<strong>隐式的数据输入</strong>导致的——我们通过观察 <code>add()</code> 函数的入参声明，并不能够发觉 a 和 b 两个数据源的存在。</p><p><code>a</code> 和 <code>b</code> 两个变量并没有以入参的形式传入，而是在函数执行过程中直接被从全局作用域“抓进来”参与计算的（如下图），这就是典型的隐式数据交换。</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p>图中的横向数据流表示函数自身的显式数据流动，方向是从入参到出参。</p><p>纵向数据流则是隐式数据流，代表函数和外界的数据交换。</p><p><strong>一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。</strong></p><p>对于 <strong>Case #2</strong> 中的姓名处理函数来说，它的不纯则是由<strong>隐式的数据输出</strong>导致的。</p><p>我们通过观察 <code> processName()</code>的 return 语句，只能够观察到“<code>fullName</code>”这个变量的输出。</p><p>但在实际的执行中，<code>processName()</code> 会偷偷地向控制台输出一行字符串，这个字符串脱离了显式数据流的流向，进而导致函数不纯（如下图）：</p><p><a class="img-fancybox" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-zoom-1.image" data-fancybox="gallery" data-caption=""><img class="post-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"><span class="post-img-tip"></span></a></p><p><strong>Case #3</strong> 中的网络请求函数，同样是与外界进行了隐式的数据交换，导致出现了显式和隐式的两条交叉的数据流。这里不再赘述。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>行文至此，大家已经对“纯函数”和“副作用”的内涵有了透彻的理解。</p><p>此时你或许已经开始好奇：创造这么多名词、制定这么多条条框框来约束的这一类特别的函数，对于我们实际的生产生活到底有什么益处呢？纯函数这东西又是何德何能，足以称得上是函数式编程知识体系的“根基”呢？</p><p>带着这些疑问，让我们开启下一节的学习吧！ღ( ´･ᴗ･` )</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p>',95)]))}]]);export{p as __pageData,e as default};
